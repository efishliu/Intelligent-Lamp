###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         10/Jul/2018  16:37:29 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Components\osal\common\OSAL_Memory.c               #
#    Command line       =  -f D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ #
#                          ¸Ä\Projects\zstack\Utilities\SerialApp\CC2530DB\.. #
#                          \..\..\Tools\CC2530DB\f8wEndev.cfg (-DCPU32MHZ     #
#                          -DROOT=__near_func -DBLINK_LEDS) -f                #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\Tools\CC2530DB\f8wConfig.cfg (-DSECURE=0       #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xfFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Components\osal\common\OSAL_Memory.c -D ZIGBEEPRO  #
#                          -D NWK_AUTO_POLL -D HAL_UART=TRUE -D               #
#                          SERIAL_APP_PORT=0 -D LCD_SUPPORTED -D              #
#                          xPOWER_SAVING -lC D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼ #
#                          «\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\Serial #
#                          App\CC2530DB\EndDeviceEB-Pro\List\ -lA             #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\EndDe #
#                          viceEB-Pro\List\ --diag_suppress Pe001,Pa010 -o    #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\EndDe #
#                          viceEB-Pro\Obj\ -e --debug --core=plain            #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ #
#                          °\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\S #
#                          erialApp\CC2530DB\ -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ° #
#                          \ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\SOURCE\ -I                     #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\ZMAIN\TI2530DB\ -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ #
#                          °\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\S #
#                          erialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\    #
#                          -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ #
#                          ¸Ä\Projects\zstack\Utilities\SerialApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\ -I       #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\MCU\CCSOC\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\INCLUDE\ -I              #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\AF\ -I                  #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\NWK\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SEC\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SAPI\ -I                #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SYS\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\ZDO\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\ZMAC\F8W\ -I                  #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\ZMAC\ -I                      #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SADDR\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SDATA\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\INCLUDE\ -I               #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\ -I       #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CH #
#                          IP\ -Ohz --require_prototypes                      #
#    List file          =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\EndDe #
#                          viceEB-Pro\List\OSAL_Memory.lst                    #
#    Object file        =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\EndDe #
#                          viceEB-Pro\Obj\OSAL_Memory.r51                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Components\osal\common\OSAL_Memory.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Memory.c
      3            Revised:        $Date: 2009-02-05 16:41:18 -0800 (Thu, 05 Feb 2009) $
      4            Revision:       $Revision: 18998 $
      5          
      6            Description:    OSAL Heap Memory management functions.
      7          
      8          
      9            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "comdef.h"
     45          #include "OSAL_Memory.h"
     46          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     47          #include "hal_assert.h"
     48          
     49          #if ( MAXMEMHEAP >= 32768 )
     50            #error MAXMEMHEAP is too big to manage!
     51          #endif
     52          
     53          // Minimum wasted bytes to justify splitting a block before allocation.
     54          #if !defined ( OSALMEM_MIN_BLKSZ )
     55            #define OSALMEM_MIN_BLKSZ    4
     56          #endif
     57          
     58          /* Profiling memory allocations showed that a significant % of very high
     59           * frequency allocations/frees are for block sizes less than or equal to 16.
     60           */
     61          #if !defined ( OSALMEM_SMALL_BLKSZ )
     62            #define OSALMEM_SMALL_BLKSZ  16
     63          #endif
     64          
     65          #if !defined ( OSALMEM_NODEBUG )
     66            #define OSALMEM_NODEBUG      TRUE
     67          #endif
     68          
     69          #if !defined ( OSALMEM_PROFILER )
     70            #define OSALMEM_PROFILER     FALSE
     71          #endif
     72          
     73          #if ( OSALMEM_PROFILER )
     74            #define OSALMEM_INIT   'X'
     75            #define OSALMEM_ALOC   'A'
     76            #define OSALMEM_REIN   'F'
     77          #endif
     78          
     79          /*********************************************************************
     80           * MACROS
     81           */
     82          
     83          /*
     84           *  The MAC_ASSERT macro is for use during debugging.
     85           *  The given expression must evaluate as "true" or else fatal error occurs.
     86           *  At that point, the call stack feature of the debugger can pinpoint where
     87           *  the problem occurred.
     88           *
     89           *  To disable this feature and save code size, the project should define
     90           *  OSALMEM_NODEBUG to TRUE.
     91           */
     92          #if ( OSALMEM_NODEBUG )
     93            #define OSALMEM_ASSERT( expr )
     94            #define OSALMEM_DEBUG( statement )
     95          #else
     96            #define OSALMEM_ASSERT( expr)        HAL_ASSERT( expr )
     97            #define OSALMEM_DEBUG( statement)    st( statement )
     98          #endif
     99          
    100          /*********************************************************************
    101           * TYPEDEFS
    102           */
    103          
    104          typedef uint16  osalMemHdr_t;
    105          
    106          /*********************************************************************
    107           * CONSTANTS
    108           */
    109          
    110          #define OSALMEM_IN_USE  0x8000
    111          
    112          /* This number sets the size of the small-block bucket. Although profiling
    113           * shows max simultaneous alloc of 16x18, timing without profiling overhead
    114           * shows that the best worst case is achieved with the following.
    115           */
    116          #define SMALLBLKHEAP    232
    117          
    118          // To maintain data alignment of the pointer returned, reserve the greater
    119          // space for the memory block header.
    120          #define HDRSZ  ( (sizeof ( halDataAlign_t ) > sizeof( osalMemHdr_t )) ? \
    121                            sizeof ( halDataAlign_t ) : sizeof( osalMemHdr_t ) )
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          
    127          /*********************************************************************
    128           * EXTERNAL VARIABLES
    129           */
    130          
    131          /*********************************************************************
    132           * EXTERNAL FUNCTIONS
    133           */
    134          
    135          /*********************************************************************
    136           * LOCAL VARIABLES
    137           */
    138          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          static osalMemHdr_t *ff1;  // First free block in the small-block bucket.
   \                     ff1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          static osalMemHdr_t *ff2;  // First free block after the small-block bucket.
   \                     ff2:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    141          
    142          #if ( OSALMEM_METRICS )
    143            static uint16 blkMax;  // Max cnt of all blocks ever seen at once.
    144            static uint16 blkCnt;  // Current cnt of all blocks.
    145            static uint16 blkFree; // Current cnt of free blocks.
    146            static uint16 memAlo;  // Current total memory allocated.
    147            static uint16 memMax;  // Max total memory ever allocated at once.
    148          #endif
    149          
    150          #if ( OSALMEM_PROFILER )
    151            #define OSALMEM_PROMAX  8
    152            /* The profiling buckets must differ by at least OSALMEM_MIN_BLKSZ; the
    153             * last bucket must equal the max alloc size. Set the bucket sizes to
    154             * whatever sizes necessary to show how your application is using memory.
    155             */
    156            static uint16 proCnt[OSALMEM_PROMAX] = { 
    157              OSALMEM_SMALL_BLKSZ, 48, 112, 176, 192, 224, 256, 65535 };
    158            static uint16 proCur[OSALMEM_PROMAX] = { 0 };
    159            static uint16 proMax[OSALMEM_PROMAX] = { 0 };
    160            static uint16 proTot[OSALMEM_PROMAX] = { 0 };
    161            static uint16 proSmallBlkMiss;
    162          #endif
    163          
    164          // Memory Allocation Heap.
    165          #if defined( EXTERNAL_RAM )
    166            static byte *theHeap = (byte *)EXT_RAM_BEG;
    167          #else

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    168            static halDataAlign_t _theHeap[ MAXMEMHEAP / sizeof( halDataAlign_t ) ];
   \                     _theHeap:
   \   000000                DS 2048
   \   000800                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    169            static uint8 *theHeap = (uint8 *)_theHeap;
   \                     theHeap:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for theHeap>`
   \   000002                REQUIRE __INIT_XDATA_I
    170          #endif
    171          
    172          /*********************************************************************
    173           * LOCAL FUNCTIONS
    174           */
    175          
    176          /*********************************************************************
    177           * @fn      osal_mem_init
    178           *
    179           * @brief   Initialize the heap memory management system.
    180           *
    181           * @param   void
    182           *
    183           * @return  void
    184           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    185          void osal_mem_init( void )
   \                     osal_mem_init:
    186          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    187            osalMemHdr_t *tmp;
    188          
    189          #if ( OSALMEM_PROFILER )
    190            osal_memset( theHeap, OSALMEM_INIT, MAXMEMHEAP );
    191          #endif
    192          
    193            // Setup a NULL block at the end of the heap for fast comparisons with zero.
    194            tmp = (osalMemHdr_t *)theHeap + (MAXMEMHEAP / HDRSZ) - 1;
    195            *tmp = 0;
   \   000004   90....       MOV     DPTR,#theHeap
   \   000007   E0           MOVX    A,@DPTR
   \   000008   24FE         ADD     A,#-0x2
   \   00000A   F8           MOV     R0,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   3407         ADDC    A,#0x7
   \   00000F   F9           MOV     R1,A
   \   000010   8882         MOV     DPL,R0
   \   000012   8983         MOV     DPH,R1
   \   000014   E4           CLR     A
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   F0           MOVX    @DPTR,A
    196          
    197            // Setup a small-block bucket.
    198            tmp = (osalMemHdr_t *)theHeap;
    199            *tmp = SMALLBLKHEAP;
   \   000018   90....       MOV     DPTR,#theHeap
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F8           MOV     R0,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F583         MOV     DPH,A
   \   000021   8882         MOV     DPL,R0
   \   000023   74E8         MOV     A,#-0x18
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
    200          
    201            // Setup the wilderness.
    202            tmp = (osalMemHdr_t *)theHeap + (SMALLBLKHEAP / HDRSZ);
   \   000029   90....       MOV     DPTR,#theHeap
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   24E8         ADD     A,#-0x18
   \   00002F   F8           MOV     R0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   3400         ADDC    A,#0x0
   \   000034   F9           MOV     R1,A
    203            *tmp = ((MAXMEMHEAP / HDRSZ) * HDRSZ) - SMALLBLKHEAP - HDRSZ;
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   7416         MOV     A,#0x16
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   7407         MOV     A,#0x7
   \   00003F   F0           MOVX    @DPTR,A
    204          
    205            // Setup a NULL block that is never freed so that the small-block bucket
    206            // is never coalesced with the wilderness.
    207            ff1 = tmp;
   \   000040   90....       MOV     DPTR,#ff1
   \   000043   E8           MOV     A,R0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   E9           MOV     A,R1
   \   000047   F0           MOVX    @DPTR,A
    208            ff2 = osal_mem_alloc( 0 );
   \   000048                ; Setup parameters for call to function osal_mem_alloc
   \   000048   7A00         MOV     R2,#0x0
   \   00004A   7B00         MOV     R3,#0x0
   \   00004C   12....       LCALL   ??osal_mem_alloc?relay
   \   00004F   90....       MOV     DPTR,#ff2
   \   000052   EA           MOV     A,R2
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   EB           MOV     A,R3
   \   000056   F0           MOVX    @DPTR,A
    209            ff1 = (osalMemHdr_t *)theHeap;
   \   000057   90....       MOV     DPTR,#theHeap
   \   00005A   12....       LCALL   ?Subroutine1 & 0xFFFF
    210          
    211          #if ( OSALMEM_METRICS )
    212            /* Start with the small-block bucket and the wilderness - don't count the
    213             * end-of-heap NULL block nor the end-of-small-block NULL block.
    214             */
    215            blkCnt = blkFree = 2;
    216          #endif
    217          }
   \                     ??CrossCallReturnLabel_0:
   \   00005D   80..         SJMP    ??Subroutine2_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   90....       MOV     DPTR,#ff1
   \   000008   E8           MOV     A,R0
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   E9           MOV     A,R1
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   22           RET
    218          
    219          /*********************************************************************
    220           * @fn      osal_mem_kick
    221           *
    222           * @brief   Kick the ff1 pointer out past the long-lived OSAL Task blocks.
    223           *          Invoke this once after all long-lived blocks have been allocated -
    224           *          presently at the end of osal_init_system().
    225           *
    226           * @param   void
    227           *
    228           * @return  void
    229           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          void osal_mem_kick( void )
   \                     osal_mem_kick:
    231          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    232            halIntState_t intState;
    233          
    234            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   E5A8         MOV     A,0xa8
   \   000006   FA           MOV     R2,A
   \   000007   C2AF         CLR     0xa8.7
    235          
    236            /* Logic in osal_mem_free() will ratchet ff1 back down to the first free
    237             * block in the small-block bucket.
    238             */
    239            ff1 = ff2;
   \   000009   90....       MOV     DPTR,#ff2
   \   00000C   12....       LCALL   ?Subroutine1 & 0xFFFF
    240          
    241            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??CrossCallReturnLabel_1:
   \   00000F   EA           MOV     A,R2
   \   000010   A2E7         MOV     C,0xE0 /* A   */.7
   \   000012                REQUIRE ?Subroutine0
   \   000012                REQUIRE _A_IEN0
   \   000012                ; // Fall through to label ?Subroutine0
    242          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   92AF         MOV     0xa8.7,C
   \   000002                REQUIRE ??Subroutine2_0
   \   000002                ; // Fall through to label ??Subroutine2_0
    243          
    244          /*********************************************************************
    245           * @fn      osal_mem_alloc
    246           *
    247           * @brief   Implementation of the allocator functionality.
    248           *
    249           * @param   size - number of bytes to allocate from the heap.
    250           *
    251           * @return  void * - pointer to the heap allocation; NULL if error or failure.
    252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    253          void *osal_mem_alloc( uint16 size )
   \                     osal_mem_alloc:
    254          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
    255            osalMemHdr_t *prev;
    256            osalMemHdr_t *hdr;
    257            halIntState_t intState;
    258            uint16 tmp;
    259            uint8 coal = 0;
   \   000005   75..00       MOV     ?V0 + 1,#0x0
    260          
    261            OSALMEM_ASSERT( size );
    262          
    263            size += HDRSZ;
   \   000008   EA           MOV     A,R2
   \   000009   2402         ADD     A,#0x2
   \   00000B   0A           INC     R2
   \   00000C   0A           INC     R2
   \   00000D   EB           MOV     A,R3
   \   00000E   3400         ADDC    A,#0x0
   \   000010   FB           MOV     R3,A
    264          
    265            // Calculate required bytes to add to 'size' to align to halDataAlign_t.
    266            if ( sizeof( halDataAlign_t ) == 2 )
    267            {
    268              size += (size & 0x01);
    269            }
    270            else if ( sizeof( halDataAlign_t ) != 1 )
    271            {
    272              const uint8 mod = size % sizeof( halDataAlign_t );
    273          
    274              if ( mod != 0 )
    275              {
    276                size += (sizeof( halDataAlign_t ) - mod);
    277              }
    278            }
    279          
    280            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000011   A2AF         MOV     C,0xa8.7
   \   000013   E4           CLR     A
   \   000014   33           RLC     A
   \   000015   F5..         MOV     ?V0 + 0,A
   \   000017   C2AF         CLR     0xa8.7
    281          
    282            // Smaller allocations are first attempted in the small-block bucket.
    283            if ( size <= OSALMEM_SMALL_BLKSZ )
   \   000019   EA           MOV     A,R2
   \   00001A   9411         SUBB    A,#0x11
   \   00001C   EB           MOV     A,R3
   \   00001D   9400         SUBB    A,#0x0
   \   00001F   5005         JNC     ??osal_mem_alloc_0
    284            {
    285              hdr = ff1;
   \   000021   90....       MOV     DPTR,#ff1
   \   000024   8003         SJMP    ??osal_mem_alloc_1
    286            }
    287            else
    288            {
    289              hdr = ff2;
   \                     ??osal_mem_alloc_0:
   \   000026   90....       MOV     DPTR,#ff2
   \                     ??osal_mem_alloc_1:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F9           MOV     R1,A
    290            }
    291            tmp = *hdr;
   \   00002E   8882         MOV     DPL,R0
   \   000030   8983         MOV     DPH,R1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FE           MOV     R6,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FF           MOV     R7,A
    292          
    293            do
    294            {
    295              if ( tmp & OSALMEM_IN_USE )
   \                     ??osal_mem_alloc_2:
   \   000037   EF           MOV     A,R7
   \   000038   5480         ANL     A,#0x80
   \   00003A   6009         JZ      ??osal_mem_alloc_3
    296              {
    297                tmp ^= OSALMEM_IN_USE;
   \   00003C   7480         MOV     A,#-0x80
   \   00003E   6F           XRL     A,R7
   \   00003F   FF           MOV     R7,A
    298                coal = 0;
   \   000040   75..00       MOV     ?V0 + 1,#0x0
   \   000043   8074         SJMP    ??osal_mem_alloc_4
    299              }
    300              else
    301              {
    302                if ( coal != 0 )
   \                     ??osal_mem_alloc_3:
   \   000045   E5..         MOV     A,?V0 + 1
   \   000047   A2E0         MOV     C,0xE0 /* A   */.0
   \   000049   5060         JNC     ??osal_mem_alloc_5
    303                {
    304          #if ( OSALMEM_METRICS )
    305                  blkCnt--;
    306                  blkFree--;
    307          #endif
    308          
    309                  *prev += *hdr;
   \   00004B   8882         MOV     DPL,R0
   \   00004D   8983         MOV     DPH,R1
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F5..         MOV     ?V0 + 2,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F5..         MOV     ?V0 + 3,A
   \   000056   8C82         MOV     DPL,R4
   \   000058   8D83         MOV     DPH,R5
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   25..         ADD     A,?V0 + 2
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   35..         ADDC    A,?V0 + 3
   \   000062   F0           MOVX    @DPTR,A
    310          
    311                  if ( *prev >= size )
   \   000063   8C82         MOV     DPL,R4
   \   000065   8D83         MOV     DPH,R5
   \   000067   C3           CLR     C
   \   000068   E0           MOVX    A,@DPTR
   \   000069   9A           SUBB    A,R2
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   9B           SUBB    A,R3
   \   00006D   404A         JC      ??osal_mem_alloc_4
    312                  {
    313                    hdr = prev;
   \   00006F   EC           MOV     A,R4
   \   000070   F8           MOV     R0,A
   \   000071   ED           MOV     A,R5
   \   000072   F9           MOV     R1,A
    314                    tmp = *hdr;
   \   000073   8882         MOV     DPL,R0
   \   000075   8983         MOV     DPH,R1
   \   000077   E0           MOVX    A,@DPTR
   \   000078   FE           MOV     R6,A
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FF           MOV     R7,A
    315                    break;
    316                  }
    317                }
    318                else
    319                {
    320                  if ( tmp >= size )
    321                  {
    322                    break;
    323                  }
    324          
    325                  coal = 1;
    326                  prev = hdr;
    327                }
    328              }
    329          
    330              hdr = (osalMemHdr_t *)((uint8 *)hdr + tmp);
    331          
    332              tmp = *hdr;
    333              if ( tmp == 0 )
    334              {
    335                hdr = NULL;
    336                break;
    337              }
    338          
    339          
    340            } while ( 1 );
    341          
    342            if ( hdr != NULL )
   \                     ??osal_mem_alloc_6:
   \   00007C   E8           MOV     A,R0
   \   00007D   49           ORL     A,R1
   \   00007E   6067         JZ      ??osal_mem_alloc_7
    343            {
    344              tmp -= size;
   \   000080   C3           CLR     C
   \   000081   EE           MOV     A,R6
   \   000082   9A           SUBB    A,R2
   \   000083   FE           MOV     R6,A
   \   000084   EF           MOV     A,R7
   \   000085   9B           SUBB    A,R3
   \   000086   FF           MOV     R7,A
    345          
    346              // Determine whether the threshold for splitting is met.
    347              if ( tmp >= OSALMEM_MIN_BLKSZ )
   \   000087   C3           CLR     C
   \   000088   EE           MOV     A,R6
   \   000089   9404         SUBB    A,#0x4
   \   00008B   EF           MOV     A,R7
   \   00008C   9400         SUBB    A,#0x0
   \   00008E   4045         JC      ??osal_mem_alloc_8
    348              {
    349                // Split the block before allocating it.
    350                osalMemHdr_t *next = (osalMemHdr_t *)((uint8 *)hdr + size);
    351                *next = tmp;
   \   000090   E8           MOV     A,R0
   \   000091   2A           ADD     A,R2
   \   000092   F582         MOV     DPL,A
   \   000094   E9           MOV     A,R1
   \   000095   3B           ADDC    A,R3
   \   000096   F583         MOV     DPH,A
   \   000098   EE           MOV     A,R6
   \   000099   F0           MOVX    @DPTR,A
   \   00009A   A3           INC     DPTR
   \   00009B   EF           MOV     A,R7
   \   00009C   F0           MOVX    @DPTR,A
    352                *hdr = (size | OSALMEM_IN_USE);
   \   00009D   EB           MOV     A,R3
   \   00009E   4480         ORL     A,#0x80
   \   0000A0   FB           MOV     R3,A
   \   0000A1   8882         MOV     DPL,R0
   \   0000A3   8983         MOV     DPH,R1
   \   0000A5   EA           MOV     A,R2
   \   0000A6   F0           MOVX    @DPTR,A
   \   0000A7   A3           INC     DPTR
   \   0000A8   EB           MOV     A,R3
   \   0000A9   8032         SJMP    ??osal_mem_alloc_9
    353          
    354          #if ( OSALMEM_METRICS )
    355                blkCnt++;
    356                if ( blkMax < blkCnt )
    357                {
    358                  blkMax = blkCnt;
    359                }
    360                memAlo += size;
    361          #endif
    362              }
   \                     ??osal_mem_alloc_5:
   \   0000AB   C3           CLR     C
   \   0000AC   EE           MOV     A,R6
   \   0000AD   9A           SUBB    A,R2
   \   0000AE   EF           MOV     A,R7
   \   0000AF   9B           SUBB    A,R3
   \   0000B0   50CA         JNC     ??osal_mem_alloc_6
   \   0000B2   75..01       MOV     ?V0 + 1,#0x1
   \   0000B5   E8           MOV     A,R0
   \   0000B6   FC           MOV     R4,A
   \   0000B7   E9           MOV     A,R1
   \   0000B8   FD           MOV     R5,A
   \                     ??osal_mem_alloc_4:
   \   0000B9   E8           MOV     A,R0
   \   0000BA   2E           ADD     A,R6
   \   0000BB   F8           MOV     R0,A
   \   0000BC   E9           MOV     A,R1
   \   0000BD   3F           ADDC    A,R7
   \   0000BE   F9           MOV     R1,A
   \   0000BF   8882         MOV     DPL,R0
   \   0000C1   8983         MOV     DPH,R1
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   FE           MOV     R6,A
   \   0000C5   A3           INC     DPTR
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   FF           MOV     R7,A
   \   0000C8   EE           MOV     A,R6
   \   0000C9   4F           ORL     A,R7
   \   0000CA   6003         JZ      $+5
   \   0000CC   02....       LJMP    ??osal_mem_alloc_2 & 0xFFFF
   \   0000CF   7800         MOV     R0,#0x0
   \   0000D1   7900         MOV     R1,#0x0
   \   0000D3   8012         SJMP    ??osal_mem_alloc_7
    363              else
    364              {
    365          #if ( OSALMEM_METRICS )
    366                memAlo += *hdr;
    367                blkFree--;
    368          #endif
    369          
    370                *hdr |= OSALMEM_IN_USE;
   \                     ??osal_mem_alloc_8:
   \   0000D5   8882         MOV     DPL,R0
   \   0000D7   8983         MOV     DPH,R1
   \   0000D9   A3           INC     DPTR
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   4480         ORL     A,#0x80
   \                     ??osal_mem_alloc_9:
   \   0000DD   F0           MOVX    @DPTR,A
    371              }
    372          
    373          #if ( OSALMEM_METRICS )
    374              if ( memMax < memAlo )
    375              {
    376                memMax = memAlo;
    377              }
    378          #endif
    379          
    380          #if ( OSALMEM_PROFILER )
    381            {
    382              byte idx;
    383              size = *hdr ^ OSALMEM_IN_USE;
    384          
    385              for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    386              {
    387                if ( size <= proCnt[idx] )
    388                {
    389                  break;
    390                }
    391              }
    392              proCur[idx]++;
    393              if ( proMax[idx] < proCur[idx] )
    394              {
    395                proMax[idx] = proCur[idx];
    396              }
    397              proTot[idx]++;
    398            }
    399          #endif
    400          
    401              hdr++;
   \   0000DE   E8           MOV     A,R0
   \   0000DF   2402         ADD     A,#0x2
   \   0000E1   08           INC     R0
   \   0000E2   08           INC     R0
   \   0000E3   E9           MOV     A,R1
   \   0000E4   3400         ADDC    A,#0x0
   \   0000E6   F9           MOV     R1,A
    402          
    403          #if ( OSALMEM_PROFILER )
    404              osal_memset( (byte *)hdr, OSALMEM_ALOC, (size - HDRSZ) );
    405          
    406              /* A small-block could not be allocated in the small-block bucket.
    407               * When this occurs significantly frequently, increase the size of the
    408               * bucket in order to restore better worst case run times. Set the first
    409               * profiling bucket size in proCnt[] to the small-block bucket size and
    410               * divide proSmallBlkMiss by the corresponding proTot[] size to get % miss.
    411               * Best worst case time on TrasmitApp was achieved at a 0-15% miss rate
    412               * during steady state Tx load, 0% during idle and steady state Rx load.
    413               */
    414              if ( (size <= OSALMEM_SMALL_BLKSZ) && (hdr > ff2) )
    415              {
    416                proSmallBlkMiss++;
    417              }
    418          #endif
    419            }
    420          
    421            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_alloc_7:
   \   0000E7   E5..         MOV     A,?V0 + 0
   \   0000E9   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000EB   92AF         MOV     0xa8.7,C
    422          
    423            return (void *)hdr;
   \   0000ED   E8           MOV     A,R0
   \   0000EE   FA           MOV     R2,A
   \   0000EF   E9           MOV     A,R1
   \   0000F0   FB           MOV     R3,A
   \   0000F1   7F05         MOV     R7,#0x5
   \   0000F3   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000F6                REQUIRE _A_IEN0
    424          }
    425          
    426          /*********************************************************************
    427           * @fn      osal_mem_free
    428           *
    429           * @brief   Implementation of the de-allocator functionality.
    430           *
    431           * @param   ptr - pointer to the memory to free.
    432           *
    433           * @return  void
    434           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    435          void osal_mem_free( void *ptr )
   \                     osal_mem_free:
    436          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    437            osalMemHdr_t *currHdr;
    438            halIntState_t intState;
    439          
    440            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   A2AF         MOV     C,0xa8.7
   \   000006   E4           CLR     A
   \   000007   33           RLC     A
   \   000008   FC           MOV     R4,A
   \   000009   C2AF         CLR     0xa8.7
    441          
    442            OSALMEM_ASSERT( ptr );
    443          
    444            currHdr = (osalMemHdr_t *)ptr - 1;
   \   00000B   EA           MOV     A,R2
   \   00000C   24FE         ADD     A,#-0x2
   \   00000E   F8           MOV     R0,A
   \   00000F   EB           MOV     A,R3
   \   000010   34FF         ADDC    A,#-0x1
   \   000012   F9           MOV     R1,A
    445          
    446            // Has this block already been freed?
    447            OSALMEM_ASSERT( *currHdr & OSALMEM_IN_USE );
    448          
    449            *currHdr &= ~OSALMEM_IN_USE;
   \   000013   8882         MOV     DPL,R0
   \   000015   8983         MOV     DPH,R1
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   547F         ANL     A,#0x7f
   \   00001B   F0           MOVX    @DPTR,A
    450          
    451          #if ( OSALMEM_PROFILER )
    452            {
    453              uint16 size = *currHdr;
    454              byte idx;
    455          
    456              for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    457              {
    458                if ( size <= proCnt[idx] )
    459                {
    460                  break;
    461                }
    462              }
    463          
    464              proCur[idx]--;
    465            }
    466          #endif
    467          
    468          #if ( OSALMEM_METRICS )
    469            memAlo -= *currHdr;
    470            blkFree++;
    471          #endif
    472          
    473            if ( ff1 > currHdr )
   \   00001C   90....       MOV     DPTR,#ff1
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FA           MOV     R2,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FB           MOV     R3,A
   \   000024   C3           CLR     C
   \   000025   E8           MOV     A,R0
   \   000026   9A           SUBB    A,R2
   \   000027   E9           MOV     A,R1
   \   000028   9B           SUBB    A,R3
   \   000029   5008         JNC     ??osal_mem_free_0
    474            {
    475              ff1 = currHdr;
   \   00002B   90....       MOV     DPTR,#ff1
   \   00002E   E8           MOV     A,R0
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   A3           INC     DPTR
   \   000031   E9           MOV     A,R1
   \   000032   F0           MOVX    @DPTR,A
    476            }
    477          
    478          #if ( OSALMEM_PROFILER )
    479            osal_memset( (byte *)currHdr+HDRSZ, OSALMEM_REIN, (*currHdr - HDRSZ) );
    480          #endif
    481          
    482            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_free_0:
   \   000033   EC           MOV     A,R4
   \   000034   A2E0         MOV     C,0xE0 /* A   */.0
   \   000036   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000039                REQUIRE _A_IEN0
    483          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for theHeap>`:
   \   000000   ....         DW _theHeap

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_kick?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_kick

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_alloc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_alloc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_free?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_free
    484          
    485          #if ( OSALMEM_METRICS )
    486          /*********************************************************************
    487           * @fn      osal_heap_block_max
    488           *
    489           * @brief   Return the maximum number of blocks ever allocated at once.
    490           *
    491           * @param   none
    492           *
    493           * @return  Maximum number of blocks ever allocated at once.
    494           */
    495          uint16 osal_heap_block_max( void )
    496          {
    497            return blkMax;
    498          }
    499          
    500          /*********************************************************************
    501           * @fn      osal_heap_block_cnt
    502           *
    503           * @brief   Return the current number of blocks now allocated.
    504           *
    505           * @param   none
    506           *
    507           * @return  Current number of blocks now allocated.
    508           */
    509          uint16 osal_heap_block_cnt( void )
    510          {
    511            return blkCnt;
    512          }
    513          
    514          /*********************************************************************
    515           * @fn      osal_heap_block_free
    516           *
    517           * @brief   Return the current number of free blocks.
    518           *
    519           * @param   none
    520           *
    521           * @return  Current number of free blocks.
    522           */
    523          uint16 osal_heap_block_free( void )
    524          {
    525            return blkFree;
    526          }
    527          
    528          /*********************************************************************
    529           * @fn      osal_heap_mem_used
    530           *
    531           * @brief   Return the current number of bytes allocated.
    532           *
    533           * @param   none
    534           *
    535           * @return  Current number of bytes allocated.
    536           */
    537          uint16 osal_heap_mem_used( void )
    538          {
    539            return memAlo;
    540          }
    541          #endif
    542          
    543          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    544          /*********************************************************************
    545           * @fn      osal_heap_high_water
    546           *
    547           * @brief   Return the highest byte ever allocated in the heap.
    548           *
    549           * @param   none
    550           *
    551           * @return  Highest number of bytes ever used by the stack.
    552           */
    553          uint16 osal_heap_high_water( void )
    554          {
    555          #if ( OSALMEM_METRICS )
    556            return memMax;
    557          #else
    558            return MAXMEMHEAP;
    559          #endif
    560          }
    561          #endif
    562          
    563          /*********************************************************************
    564          *********************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     osal_mem_alloc          0      0     13
     osal_mem_free           2      0      0
     osal_mem_init           2      0      0
       -> osal_mem_alloc     4      0      0
     osal_mem_kick           2      0      0


   Segment part sizes:

     Function/Label             Bytes
     --------------             -----
     _A_IEN0                       1
     ff1                           2
     ff2                           2
     _theHeap                   2048
     theHeap                       2
     osal_mem_init                95
     ??Subroutine2_0               7
     ?Subroutine1                 14
     osal_mem_kick                18
     ?Subroutine0                  2
     osal_mem_alloc              246
     osal_mem_free                57
     ?<Initializer for theHeap>    2
     ??osal_mem_init?relay         6
     ??osal_mem_kick?relay         6
     ??osal_mem_alloc?relay        6
     ??osal_mem_free?relay         6

 
   439 bytes in segment BANKED_CODE
    24 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
 2 052 bytes in segment XDATA_Z
 
   465 bytes of CODE  memory
     0 bytes of DATA  memory (+ 1 byte shared)
 2 054 bytes of XDATA memory

Errors: none
Warnings: none
