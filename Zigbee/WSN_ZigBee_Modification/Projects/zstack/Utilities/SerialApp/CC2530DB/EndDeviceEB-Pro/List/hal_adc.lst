###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         10/Jul/2018  16:37:22 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Components\hal\target\CC2530EB\hal_adc.c           #
#    Command line       =  -f D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ #
#                          ¸Ä\Projects\zstack\Utilities\SerialApp\CC2530DB\.. #
#                          \..\..\Tools\CC2530DB\f8wEndev.cfg (-DCPU32MHZ     #
#                          -DROOT=__near_func -DBLINK_LEDS) -f                #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\Tools\CC2530DB\f8wConfig.cfg (-DSECURE=0       #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xfFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Components\hal\target\CC2530EB\hal_adc.c -D        #
#                          ZIGBEEPRO -D NWK_AUTO_POLL -D HAL_UART=TRUE -D     #
#                          SERIAL_APP_PORT=0 -D LCD_SUPPORTED -D              #
#                          xPOWER_SAVING -lC D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼ #
#                          «\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\Serial #
#                          App\CC2530DB\EndDeviceEB-Pro\List\ -lA             #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\EndDe #
#                          viceEB-Pro\List\ --diag_suppress Pe001,Pa010 -o    #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\EndDe #
#                          viceEB-Pro\Obj\ -e --debug --core=plain            #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ #
#                          °\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\S #
#                          erialApp\CC2530DB\ -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ° #
#                          \ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\SOURCE\ -I                     #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\ZMAIN\TI2530DB\ -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ #
#                          °\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\S #
#                          erialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\    #
#                          -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ #
#                          ¸Ä\Projects\zstack\Utilities\SerialApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\ -I       #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\MCU\CCSOC\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\INCLUDE\ -I              #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\AF\ -I                  #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\NWK\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SEC\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SAPI\ -I                #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SYS\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\ZDO\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\ZMAC\F8W\ -I                  #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\ZMAC\ -I                      #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SADDR\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SDATA\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\INCLUDE\ -I               #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\ -I       #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CH #
#                          IP\ -Ohz --require_prototypes                      #
#    List file          =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\EndDe #
#                          viceEB-Pro\List\hal_adc.lst                        #
#    Object file        =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\EndDe #
#                          viceEB-Pro\Obj\hal_adc.r51                         #
#                                                                             #
#                                                                             #
###############################################################################

D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Components\hal\target\CC2530EB\hal_adc.c
      1          /**************************************************************************************************
      2            Filename:       hal_adc.c
      3            Revised:        $Date: 2009-03-13 05:45:44 -0700 (Fri, 13 Mar 2009) $
      4            Revision:       $Revision: 19408 $
      5          
      6            Description:    This file contains the interface to the HAL ADC.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include  "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb5
   \   unsigned char volatile __sfr ADCCON2
   \                     ADCCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr ADCL
   \                     ADCL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1
     44          #include  "hal_defs.h"
     45          #include  "hal_types.h"
     46          #include  "hal_adc.h"
     47          
     48          /**************************************************************************************************
     49           *                                            CONSTANTS
     50           **************************************************************************************************/
     51          #define HAL_ADC_EOC         0x80    /* End of Conversion bit */
     52          #define HAL_ADC_START       0x40    /* Starts Conversion */
     53          
     54          #define HAL_ADC_STSEL_EXT   0x00    /* External Trigger */
     55          #define HAL_ADC_STSEL_FULL  0x10    /* Full Speed, No Trigger */
     56          #define HAL_ADC_STSEL_T1C0  0x20    /* Timer1, Channel 0 Compare Event Trigger */
     57          #define HAL_ADC_STSEL_ST    0x30    /* ADCCON1.ST =1 Trigger */
     58          
     59          #define HAL_ADC_RAND_NORM   0x00    /* Normal Operation */
     60          #define HAL_ADC_RAND_LFSR   0x04    /* Clock LFSR */
     61          #define HAL_ADC_RAND_SEED   0x08    /* Seed Modulator */
     62          #define HAL_ADC_RAND_STOP   0x0c    /* Stop Random Generator */
     63          #define HAL_ADC_RAND_BITS   0x0c    /* Bits [3:2] */
     64          
     65          #define HAL_ADC_REF_125V    0x00    /* Internal 1.25V Reference */
     66          #define HAL_ADC_REF_AIN7    0x40    /* AIN7 Reference */
     67          #define HAL_ADC_REF_AVDD    0x80    /* AVDD_SOC Pin Reference */
     68          #define HAL_ADC_REF_DIFF    0xc0    /* AIN7,AIN6 Differential Reference */
     69          #define HAL_ADC_REF_BITS    0xc0    /* Bits [7:6] */
     70          
     71          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     72          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     73          #define HAL_ADC_DEC_256     0x20    /* Decimate by 256 : 12-bit resolution */
     74          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     75          #define HAL_ADC_DEC_BITS    0x30    /* Bits [5:4] */
     76          
     77          #define HAL_ADC_CHN_AIN0    0x00    /* AIN0 */
     78          #define HAL_ADC_CHN_AIN1    0x01    /* AIN1 */
     79          #define HAL_ADC_CHN_AIN2    0x02    /* AIN2 */
     80          #define HAL_ADC_CHN_AIN3    0x03    /* AIN3 */
     81          #define HAL_ADC_CHN_AIN4    0x04    /* AIN4 */
     82          #define HAL_ADC_CHN_AIN5    0x05    /* AIN5 */
     83          #define HAL_ADC_CHN_AIN6    0x06    /* AIN6 */
     84          #define HAL_ADC_CHN_AIN7    0x07    /* AIN7 */
     85          #define HAL_ADC_CHN_A0A1    0x08    /* AIN0,AIN1 */
     86          #define HAL_ADC_CHN_A2A3    0x09    /* AIN2,AIN3 */
     87          #define HAL_ADC_CHN_A4A5    0x0a    /* AIN4,AIN5 */
     88          #define HAL_ADC_CHN_A6A7    0x0b    /* AIN6,AIN7 */
     89          #define HAL_ADC_CHN_GND     0x0c    /* GND */
     90          #define HAL_ADC_CHN_VREF    0x0d    /* Positive voltage reference */
     91          #define HAL_ADC_CHN_TEMP    0x0e    /* Temperature sensor */
     92          #define HAL_ADC_CHN_VDD3    0x0f    /* VDD/3 */
     93          #define HAL_ADC_CHN_BITS    0x0f    /* Bits [3:0] */
     94          
     95          #define HAL_ADC_STSEL       HAL_ADC_STSEL_ST
     96          #define HAL_ADC_RAND_GEN    HAL_ADC_RAND_STOP
     97          #define HAL_ADC_REF_VOLT    HAL_ADC_REF_AVDD
     98          #define HAL_ADC_DEC_RATE    HAL_ADC_DEC_064
     99          #define HAL_ADC_SCHN        HAL_ADC_CHN_VDD3
    100          #define HAL_ADC_ECHN        HAL_ADC_CHN_GND
    101          
    102          
    103          /* Vdd limit values */

   \                                 In  segment CODE_C, align 1
    104          static __code const uint16 HalAdcVddLimit[] =
   \                     HalAdcVddLimit:
   \   000000   9C36         DW 13980
   \   000002   063A         DW 14854
   \   000004   703D         DW 15728
   \   000006   D940         DW 16601
   \   000008   4344         DW 17475
   \   00000A   AD47         DW 18349
   \   00000C   174B         DW 19223
   \   00000E   814E         DW 20097
   \   000010   EA51         DW 20970
    105          {
    106            0x369C,       /*  VDD Limit - 1.6v  */
    107            0x3A06,       /*  VDD Limit - 1.7v  */
    108            0x3D70,       /*  VDD Limit - 1.8v  */
    109            0x40D9,       /*  VDD Limit - 1.9v  */
    110            0x4443,       /*  VDD Limit - 2.0v  */
    111            0x47AD,       /*  VDD Limit - 2.1v  */
    112            0x4B17,       /*  VDD Limit - 2.2v  */
    113            0x4E81,       /*  VDD Limit - 2.3v  */
    114            0x51EA,       /*  VDD Limit - 2.4v  */
    115          };
    116          
    117          
    118          /**************************************************************************************************
    119           *                                              MACROS
    120           **************************************************************************************************/
    121          #define HAL_ADC_CLR_EOC()   asm("PUSH A"); asm("MOV A,ADCL"); asm("MOV A,ADCH"); asm("POP A");
    122          
    123          /**************************************************************************************************
    124           *                                            TYPEDEFS
    125           **************************************************************************************************/
    126          
    127          /**************************************************************************************************
    128           *                                         GLOBAL VARIABLES
    129           **************************************************************************************************/
    130          
    131          /**************************************************************************************************
    132           *                                          FUNCTIONS - API
    133           **************************************************************************************************/
    134          extern bool HalAdcCheckVdd (uint8 limit);
    135          
    136          /**************************************************************************************************
    137           * @fn      HalAdcInit
    138           *
    139           * @brief   Initialize ADC Service
    140           *
    141           * @param   None
    142           *
    143           * @return  None
    144           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void HalAdcInit (void)
   \                     HalAdcInit:
    146          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    147          #if (HAL_ADC == TRUE)
    148            volatile uint8  tmp;
    149          
    150            ADCCON1 = HAL_ADC_STSEL | HAL_ADC_RAND_GEN | 0x03;
   \   000009   75B43F       MOV     0xb4,#0x3f
    151            ADCCON2 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_SCHN;
   \   00000C   75B58F       MOV     0xb5,#-0x71
    152            /*
    153            *  After reset, the first ADC reading of the extra conversion always reads GND level.
    154            *  We will do a few dummy conversions to bypass this bug.
    155            */
    156            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00000F   E5BA         MOV     A,0xba
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   F0           MOVX    @DPTR,A
    157            tmp = ADCH;
   \   000018   E5BB         MOV     A,0xbb
   \   00001A   F0           MOVX    @DPTR,A
    158            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00001B   75B68C       MOV     0xb6,#-0x74
    159            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_0:
   \   00001E   E5B4         MOV     A,0xb4
   \   000020   A2E7         MOV     C,0xE0 /* A   */.7
   \   000022   50FA         JNC     ??HalAdcInit_0
    160            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000024   E5BA         MOV     A,0xba
   \   000026   F0           MOVX    @DPTR,A
    161            tmp = ADCH;
   \   000027   E5BB         MOV     A,0xbb
   \   000029   F0           MOVX    @DPTR,A
    162            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00002A   75B68C       MOV     0xb6,#-0x74
    163            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_1:
   \   00002D   E5B4         MOV     A,0xb4
   \   00002F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000031   50FA         JNC     ??HalAdcInit_1
    164            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000033   E5BA         MOV     A,0xba
   \   000035   F0           MOVX    @DPTR,A
    165            tmp = ADCH;
   \   000036   E5BB         MOV     A,0xbb
   \   000038   F0           MOVX    @DPTR,A
    166          #endif
    167          }
   \   000039   7401         MOV     A,#0x1
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003E   D083         POP     DPH
   \   000040   D082         POP     DPL
   \   000042   02....       LJMP    ?BRET
   \   000045                REQUIRE ADCCON1
   \   000045                REQUIRE ADCCON2
   \   000045                REQUIRE ADCL
   \   000045                REQUIRE ADCH
   \   000045                REQUIRE ADCCON3
    168          
    169          /**************************************************************************************************
    170           * @fn      HalAdcRead
    171           *
    172           * @brief   Read the ADC based on given channel and resolution
    173           *
    174           * @param   channel - channel where ADC will be read
    175           * @param   resolution - the resolution of the value
    176           *
    177           * @return  16 bit value of the ADC in offset binary format.
    178           *          Note that the ADC is "bipolar", which means the GND (0V) level is mid-scale.
    179           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    180          uint16 HalAdcRead (uint8 channel, uint8 resolution)
   \                     HalAdcRead:
    181          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FC           MOV     R4,A
   \   00000C   EA           MOV     A,R2
   \   00000D   FD           MOV     R5,A
    182            int16  reading = 0;
    183          
    184          #if (HAL_ADC == TRUE)
    185          
    186            uint8   i, resbits;
    187            uint8   adctemp;
    188            volatile  uint8 tmp;
    189            uint8  adcChannel = 1;
   \   00000E   7901         MOV     R1,#0x1
    190          
    191            /*
    192            * If Analog input channel is AIN0..AIN7, make sure corresponing P0 I/O pin is enabled.  The code
    193            * does NOT disable the pin at the end of this function.  I think it is better to leave the pin
    194            * enabled because the results will be more accurate.  Because of the inherent capacitance on the
    195            * pin, it takes time for the voltage on the pin to charge up to its steady-state level.  If
    196            * HalAdcRead() has to turn on the pin for every conversion, the results may show a lower voltage
    197            * than actuality because the pin did not have time to fully charge.
    198            */
    199            if (channel < 8)
   \   000010   EC           MOV     A,R4
   \   000011   C3           CLR     C
   \   000012   9408         SUBB    A,#0x8
   \   000014   500E         JNC     ??HalAdcRead_0
    200            {
    201              for (i=0; i < channel; i++)
   \   000016   7800         MOV     R0,#0x0
   \   000018   8005         SJMP    ??HalAdcRead_1
    202              {
    203                adcChannel <<= 1;
   \                     ??HalAdcRead_2:
   \   00001A   E9           MOV     A,R1
   \   00001B   C3           CLR     C
   \   00001C   33           RLC     A
   \   00001D   F9           MOV     R1,A
    204              }
   \   00001E   08           INC     R0
   \                     ??HalAdcRead_1:
   \   00001F   E8           MOV     A,R0
   \   000020   C3           CLR     C
   \   000021   9C           SUBB    A,R4
   \   000022   40F6         JC      ??HalAdcRead_2
    205            }
    206          
    207            /* Enable channel */
    208            ADCCFG |= adcChannel;
   \                     ??HalAdcRead_0:
   \   000024   E9           MOV     A,R1
   \   000025   42F2         ORL     0xf2,A
    209          
    210            /* Convert resolution to decimation rate */
    211            switch (resolution)
   \   000027   ED           MOV     A,R5
   \   000028   14           DEC     A
   \   000029   6008         JZ      ??HalAdcRead_3
   \   00002B   14           DEC     A
   \   00002C   6009         JZ      ??HalAdcRead_4
   \   00002E   14           DEC     A
   \   00002F   600A         JZ      ??HalAdcRead_5
   \   000031   800C         SJMP    ??HalAdcRead_6
    212            {
    213              case HAL_ADC_RESOLUTION_8:
    214                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcRead_3:
   \   000033   7800         MOV     R0,#0x0
    215                break;
   \   000035   800A         SJMP    ??HalAdcRead_7
    216              case HAL_ADC_RESOLUTION_10:
    217                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcRead_4:
   \   000037   7810         MOV     R0,#0x10
    218                break;
   \   000039   8006         SJMP    ??HalAdcRead_7
    219              case HAL_ADC_RESOLUTION_12:
    220                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcRead_5:
   \   00003B   7820         MOV     R0,#0x20
    221                break;
   \   00003D   8002         SJMP    ??HalAdcRead_7
    222              case HAL_ADC_RESOLUTION_14:
    223              default:
    224                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcRead_6:
   \   00003F   7830         MOV     R0,#0x30
    225                break;
    226            }
    227          
    228            /* read ADCL,ADCH to clear EOC */
    229            tmp = ADCL;
   \                     ??HalAdcRead_7:
   \   000041   E5BA         MOV     A,0xba
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   F0           MOVX    @DPTR,A
    230            tmp = ADCH;
   \   00004A   E5BB         MOV     A,0xbb
   \   00004C   F0           MOVX    @DPTR,A
    231          
    232            /* Setup Sample */
    233            adctemp = ADCCON3;
   \   00004D   E5B6         MOV     A,0xb6
    234            adctemp &= ~(HAL_ADC_CHN_BITS | HAL_ADC_DEC_BITS | HAL_ADC_REF_BITS);
    235            adctemp |= channel | resbits | HAL_ADC_REF_VOLT;
    236          
    237            /* writing to this register starts the extra conversion */
    238            ADCCON3 = adctemp;
   \   00004F   EC           MOV     A,R4
   \   000050   48           ORL     A,R0
   \   000051   4480         ORL     A,#0x80
   \   000053   F5B6         MOV     0xb6,A
    239          
    240            /* Wait for the conversion to be done */
    241            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcRead_8:
   \   000055   E5B4         MOV     A,0xb4
   \   000057   A2E7         MOV     C,0xE0 /* A   */.7
   \   000059   50FA         JNC     ??HalAdcRead_8
    242          
    243            /* Disable channel after done conversion */
    244            ADCCFG &= (adcChannel ^ 0xFF);
   \   00005B   74FF         MOV     A,#-0x1
   \   00005D   69           XRL     A,R1
   \   00005E   52F2         ANL     0xf2,A
    245          
    246            /* Read the result */
    247            reading = (int16) (ADCL);
   \   000060   E5BA         MOV     A,0xba
   \   000062   F5..         MOV     ?V0 + 0,A
    248            reading |= (int16) (ADCH << 8);
   \   000064   E5BB         MOV     A,0xbb
   \   000066   AA..         MOV     R2,?V0 + 0
   \   000068   FB           MOV     R3,A
    249          
    250            /* Treat small negative as 0 */
    251            if (reading < 0)
   \   000069   C3           CLR     C
   \   00006A   9400         SUBB    A,#0x0
   \   00006C   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00006E   65D0         XRL     A,PSW
   \   000070   33           RLC     A
   \   000071   5004         JNC     ??HalAdcRead_9
    252              reading = 0;
   \   000073   7A00         MOV     R2,#0x0
   \   000075   7B00         MOV     R3,#0x0
    253          
    254            switch (resolution)
   \                     ??HalAdcRead_9:
   \   000077   ED           MOV     A,R5
   \   000078   14           DEC     A
   \   000079   6008         JZ      ??HalAdcRead_10
   \   00007B   14           DEC     A
   \   00007C   600D         JZ      ??HalAdcRead_11
   \   00007E   14           DEC     A
   \   00007F   6012         JZ      ??HalAdcRead_12
   \   000081   801F         SJMP    ??HalAdcRead_13
    255            {
    256              case HAL_ADC_RESOLUTION_8:
    257                reading >>= 8;
   \                     ??HalAdcRead_10:
   \   000083   8A..         MOV     ?V0 + 0,R2
   \   000085   8B..         MOV     ?V0 + 1,R3
   \   000087   7408         MOV     A,#0x8
   \   000089   800E         SJMP    ??HalAdcRead_14
    258                break;
    259              case HAL_ADC_RESOLUTION_10:
    260                reading >>= 6;
   \                     ??HalAdcRead_11:
   \   00008B   8A..         MOV     ?V0 + 0,R2
   \   00008D   8B..         MOV     ?V0 + 1,R3
   \   00008F   7406         MOV     A,#0x6
   \   000091   8006         SJMP    ??HalAdcRead_14
    261                break;
    262              case HAL_ADC_RESOLUTION_12:
    263                reading >>= 4;
   \                     ??HalAdcRead_12:
   \   000093   8A..         MOV     ?V0 + 0,R2
   \   000095   8B..         MOV     ?V0 + 1,R3
   \   000097   7404         MOV     A,#0x4
   \                     ??HalAdcRead_14:
   \   000099   78..         MOV     R0,#?V0 + 0
   \   00009B   12....       LCALL   ?SS_SHR
   \   00009E   AA..         MOV     R2,?V0 + 0
   \   0000A0   AB..         MOV     R3,?V0 + 1
    264                break;
    265              case HAL_ADC_RESOLUTION_14:
    266              default:
    267              break;
    268            }
    269          #else
    270            // unused arguments
    271            (void) channel;
    272            (void) resolution;
    273          #endif
    274          
    275            return ((uint16)reading);
   \                     ??HalAdcRead_13:
   \   0000A2   7401         MOV     A,#0x1
   \   0000A4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A7                REQUIRE ?Subroutine0
   \   0000A7                REQUIRE ADCCFG
   \   0000A7                REQUIRE ADCL
   \   0000A7                REQUIRE ADCH
   \   0000A7                REQUIRE ADCCON3
   \   0000A7                REQUIRE ADCCON1
   \   0000A7                ; // Fall through to label ?Subroutine0
    276          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    277          
    278          /**************************************************************************************************
    279           * @fn      HalAdcCheckVdd
    280           *
    281           * @brief   Check the Vdd and return TRUE if it greater than or equal the limit
    282           *
    283           * @param   limit - limit that needs to be checked with the Vdd
    284           *
    285           * @return  TRUE if Vdd >= limit, FALSE otherwise
    286           *
    287           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    288          bool HalAdcCheckVdd (uint8 limit)
   \                     HalAdcCheckVdd:
    289          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FC           MOV     R4,A
    290            uint16 value;
    291          
    292            /* Clear ADC interrupt flag */
    293            ADCIF = 0;
   \   000007   C28D         CLR     0x88.5
    294          
    295            /* Setup the new value for conversion */
    296            ADCCON3 = (HAL_ADC_REF_125V | HAL_ADC_DEC_064 | HAL_ADC_CHN_VDD3);
   \   000009   75B60F       MOV     0xb6,#0xf
    297          
    298            /* Wait for the conversion to finish */
    299            while ( !ADCIF );
   \                     ??HalAdcCheckVdd_0:
   \   00000C   A28D         MOV     C,0x88.5
   \   00000E   50FC         JNC     ??HalAdcCheckVdd_0
    300          
    301            /* Get the result */
    302            value = ADCL;
   \   000010   E5BA         MOV     A,0xba
   \   000012   F5..         MOV     ?V0 + 0,A
    303            value |= ((uint16) ADCH) << 8;
    304          
    305            /* Check the limit and return */
    306            return ( value >= HalAdcVddLimit[limit] );
   \   000014   E5BB         MOV     A,0xbb
   \   000016   FB           MOV     R3,A
   \   000017   EC           MOV     A,R4
   \   000018   C3           CLR     C
   \   000019   33           RLC     A
   \   00001A   F8           MOV     R0,A
   \   00001B   E4           CLR     A
   \   00001C   33           RLC     A
   \   00001D   F9           MOV     R1,A
   \   00001E   74..         MOV     A,#HalAdcVddLimit & 0xff
   \   000020   28           ADD     A,R0
   \   000021   F582         MOV     DPL,A
   \   000023   74..         MOV     A,#(HalAdcVddLimit >> 8) & 0xff
   \   000025   39           ADDC    A,R1
   \   000026   F583         MOV     DPH,A
   \   000028   E4           CLR     A
   \   000029   93           MOVC    A,@A+DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   7401         MOV     A,#0x1
   \   00002D   93           MOVC    A,@A+DPTR
   \   00002E   F9           MOV     R1,A
   \   00002F   C3           CLR     C
   \   000030   E5..         MOV     A,?V0 + 0
   \   000032   98           SUBB    A,R0
   \   000033   EB           MOV     A,R3
   \   000034   99           SUBB    A,R1
   \   000035   4004         JC      ??HalAdcCheckVdd_1
   \   000037   7901         MOV     R1,#0x1
   \   000039   8002         SJMP    ??HalAdcCheckVdd_2
   \                     ??HalAdcCheckVdd_1:
   \   00003B   7900         MOV     R1,#0x0
   \                     ??HalAdcCheckVdd_2:
   \   00003D   80..         SJMP    ?Subroutine0
   \   00003F                REQUIRE _A_TCON
   \   00003F                REQUIRE ADCCON3
   \   00003F                REQUIRE ADCL
   \   00003F                REQUIRE ADCH
    307          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcCheckVdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcCheckVdd
    308          
    309          /**************************************************************************************************
    310          **************************************************************************************************/
    311          
    312          
    313          
    314          

   Maximum stack usage in bytes:

     Function       ISTACK PSTACK XSTACK
     --------       ------ ------ ------
     HalAdcCheckVdd     0      0     10
     HalAdcInit         3      0      1
     HalAdcRead         1      0     11


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     _A_TCON                   1
     ADCCON1                   1
     ADCCON2                   1
     ADCCON3                   1
     ADCL                      1
     ADCH                      1
     ADCCFG                    1
     HalAdcVddLimit           18
     HalAdcInit               69
     HalAdcRead              167
     ?Subroutine0              5
     HalAdcCheckVdd           63
     ??HalAdcInit?relay        6
     ??HalAdcRead?relay        6
     ??HalAdcCheckVdd?relay    6

 
 304 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
  18 bytes in segment CODE_C
   7 bytes in segment SFR_AN
 
 340 bytes of CODE memory
   0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
