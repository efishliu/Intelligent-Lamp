###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         03/Jul/2018  14:52:59 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Components\stack\zdo\ZDSecMgr.c                    #
#    Command line       =  -f D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ #
#                          ¸Ä\Projects\zstack\Utilities\SerialApp\CC2530DB\.. #
#                          \..\..\Tools\CC2530DB\f8wRouter.cfg (-DCPU32MHZ    #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DRTR_NWK -DBLINK_LEDS) -f                       #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\Tools\CC2530DB\f8wConfig.cfg (-DSECURE=0       #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Components\stack\zdo\ZDSecMgr.c -D ZIGBEEPRO -D    #
#                          HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D              #
#                          LCD_SUPPORTED -lC D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼ #
#                          «\WSN_ZigBee_ÐÞ¸Ä\Projects\zstack\Utilities\Serial #
#                          App\CC2530DB\RouterEB-Pro\List\ -lA                #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\Route #
#                          rEB-Pro\List\ --diag_suppress Pe001,Pa010 -o       #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\Route #
#                          rEB-Pro\Obj\ -e --debug --core=plain --dptr=16,1   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 8 -I  #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\ -I   #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\SO #
#                          URCE\ -I D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_Zig #
#                          Bee_ÐÞ¸Ä\Projects\zstack\Utilities\SerialApp\CC253 #
#                          0DB\..\..\..\ZMAIN\TI2530DB\ -I                    #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MT\ -I                        #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\INCLUDE\ -I               #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\ -I       #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\MCU\CCSOC\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\INCLUDE\ -I              #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\AF\ -I                  #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\NWK\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SEC\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SAPI\ -I                #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SYS\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\ZDO\ -I                 #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\ZMAC\F8W\ -I                  #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\ZMAC\ -I                      #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SADDR\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SDATA\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\INCLUDE\ -I               #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\ -I            #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\ -I       #
#                          D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CH #
#                          IP\ -Ohz --require_prototypes                      #
#    List file          =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\Route #
#                          rEB-Pro\List\ZDSecMgr.lst                          #
#    Object file        =  D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\ #
#                          Projects\zstack\Utilities\SerialApp\CC2530DB\Route #
#                          rEB-Pro\Obj\ZDSecMgr.r51                           #
#                                                                             #
#                                                                             #
###############################################################################

D:\ÊµÏ°×ÊÁÏ\Àí¹¤´óÎïÁªÍøÊµÏ°\ÖÕ¼«\WSN_ZigBee_ÐÞ¸Ä\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2009-03-31 09:06:47 -0700 (Tue, 31 Mar 2009) $
      4            Revision:       $Revision: 19604 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2008 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          #define ZDSECMGR_CTRL_NONE       0
     93          #define ZDSECMGR_CTRL_INIT       1
     94          #define ZDSECMGR_CTRL_TK_MASTER  2
     95          #define ZDSECMGR_CTRL_SKKE_INIT  3
     96          #define ZDSECMGR_CTRL_SKKE_WAIT  4
     97          #define ZDSECMGR_CTRL_SKKE_DONE  5
     98          #define ZDSECMGR_CTRL_SKKE_FAIL  6
     99          #define ZDSECMGR_CTRL_TK_NWK     7
    100          
    101          #define ZDSECMGR_CTRL_BASE_CNTR      1
    102          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    103          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    104          
    105          // set SKA slot maximum
    106          #define ZDSECMGR_SKA_SLOT_MAX 1
    107          
    108          // APSME Stub Implementations
    109          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    110          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    111          #define ZDSecMgrLinkKeyDataGet APSME_LinkKeyDataGet
    112          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    113          
    114          #if !defined( MAX_APS_FRAMECOUNTER_CHANGES )
    115            // The number of times the frame counter can change before
    116            // saving to NV
    117            #define MAX_APS_FRAMECOUNTER_CHANGES    10
    118          #endif
    119          
    120          /******************************************************************************
    121           * TYPEDEFS
    122           */
    123          typedef struct
    124          {
    125            uint8 extAddr[Z_EXTADDR_LEN];
    126            uint8 key[SEC_KEY_LEN];
    127          } ZDSecMgrPreConfigData_t;
    128          
    129          typedef struct
    130          {
    131            uint16 ami;
    132            uint8  key[SEC_KEY_LEN];
    133          } ZDSecMgrMasterKeyData_t;
    134          
    135          //should match APSME_LinkKeyData_t;
    136          typedef struct
    137          {
    138            uint8               key[SEC_KEY_LEN];
    139            APSME_LinkKeyData_t apsmelkd;
    140          } ZDSecMgrLinkKeyData_t;
    141          
    142          typedef struct
    143          {
    144            uint16                ami;
    145            ZDSecMgrLinkKeyData_t lkd;
    146            ZDSecMgr_Authentication_Option authenticateOption;
    147          } ZDSecMgrEntry_t;
    148          
    149          typedef struct
    150          {
    151            ZDSecMgrEntry_t* entry;
    152            uint16           parentAddr;
    153            uint8            secure;
    154            uint8            state;
    155            uint8            cntr;
    156            //uint8          next;
    157          } ZDSecMgrCtrl_t;
    158          
    159          typedef struct
    160          {
    161            uint16          nwkAddr;
    162            uint8*          extAddr;
    163            uint16          parentAddr;
    164            uint8           secure;
    165            uint8           devStatus;
    166            ZDSecMgrCtrl_t* ctrl;
    167          } ZDSecMgrDevice_t;
    168          
    169          /******************************************************************************
    170           * LOCAL VARIABLES
    171           */
    172          #if 0 // Taken out because the following functionality is only used for test
    173                // purpose. A more efficient (above) way is used. It can be put
    174                // back in if customers request for a white/black list feature.
    175          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    176          {
    177            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    178            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    179            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    180          };
    181          #endif
    182          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    184            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    185          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    186          uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for ZDSecMgrTCMasterKey>`
   \   000010                REQUIRE __INIT_XDATA_I
    187            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    188             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    189          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    190          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    191          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    192          
    193          //devtag.pro.security - remove this
    194          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    195          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    196          {
    197            //---------------------------------------------------------------------------
    198            // DEVICE A
    199            //---------------------------------------------------------------------------
    200            {
    201              // extAddr
    202              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    203          
    204              // key
    205              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    206               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    207            },
    208            //---------------------------------------------------------------------------
    209            // DEVICE B
    210            //---------------------------------------------------------------------------
    211            {
    212              // extAddr
    213              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    214          
    215              // key
    216              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    217               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    218            },
    219            //---------------------------------------------------------------------------
    220            // DEVICE C
    221            //---------------------------------------------------------------------------
    222            {
    223              // extAddr
    224              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    225          
    226              // key
    227              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    228               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    229            },
    230          };
    231          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    232          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    233          ZDSecMgrMasterKeyData_t* ZDSecMgrMasterKeyData = NULL;
   \                     ZDSecMgrMasterKeyData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    234          ZDSecMgrEntry_t*         ZDSecMgrEntries       = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          ZDSecMgrCtrl_t*          ZDSecMgrCtrlData      = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    236          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    237          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    238          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    239          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    241          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    242          APSME_LinkKeyData_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z
    243          
    244          /******************************************************************************
    245           * PRIVATE FUNCTIONS
    246           *
    247           *   ZDSecMgrMasterKeyInit
    248           *   ZDSecMgrAddrStore
    249           *   ZDSecMgrExtAddrStore
    250           *   ZDSecMgrExtAddrLookup
    251           *   ZDSecMgrMasterKeyLookup
    252           *   ZDSecMgrMasterKeyStore
    253           *   ZDSecMgrEntryInit
    254           *   ZDSecMgrEntryLookup
    255           *   ZDSecMgrEntryLookupAMI
    256           *   ZDSecMgrEntryLookupExt
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           */
    290          //-----------------------------------------------------------------------------
    291          // master key data
    292          //-----------------------------------------------------------------------------
    293          void ZDSecMgrMasterKeyInit( void );
    294          
    295          //-----------------------------------------------------------------------------
    296          // address management
    297          //-----------------------------------------------------------------------------
    298          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    299          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    300          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    301          
    302          //-----------------------------------------------------------------------------
    303          // MASTER key data
    304          //-----------------------------------------------------------------------------
    305          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key );
    306          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    307          
    308          //-----------------------------------------------------------------------------
    309          // entry data
    310          //-----------------------------------------------------------------------------
    311          void ZDSecMgrEntryInit( void );
    312          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    313          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    314          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    315          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    316          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    318          
    319          //-----------------------------------------------------------------------------
    320          // control data
    321          //-----------------------------------------------------------------------------
    322          void ZDSecMgrCtrlInit( void );
    323          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    324          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    325          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    326                                ZDSecMgrEntry_t*  entry,
    327                                ZDSecMgrCtrl_t*   ctrl );
    328          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    329          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    330          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    331                                       ZDSecMgrEntry_t*  entry );
    332          
    333          //-----------------------------------------------------------------------------
    334          // key support
    335          //-----------------------------------------------------------------------------
    336          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    337          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    338                                       uint8*  initExtAddr,
    339                                       uint16  partNwkAddr,
    340                                       uint8*  partExtAddr,
    341                                       uint8** key,
    342                                       uint8*  keyType );
    343          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    344          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    345          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    346          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    347          
    348          //-----------------------------------------------------------------------------
    349          // device entry
    350          //-----------------------------------------------------------------------------
    351          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    352          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    353          
    354          //-----------------------------------------------------------------------------
    355          // device control
    356          //-----------------------------------------------------------------------------
    357          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    358          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    359          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    360          
    361          //-----------------------------------------------------------------------------
    362          // device management
    363          //-----------------------------------------------------------------------------
    364          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    365          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    366          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    367          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    368          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    369          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    370          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    371          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    372          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    373          
    374          //-----------------------------------------------------------------------------
    375          // association management
    376          //-----------------------------------------------------------------------------
    377          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    378          
    379          //-----------------------------------------------------------------------------
    380          // authentication management
    381          //-----------------------------------------------------------------------------
    382          void ZDSecMgrAuthInitiate( uint8* responder );
    383          void ZDSecMgrAuthNwkKey( void );
    384          
    385          /******************************************************************************
    386           * @fn          ZDSecMgrMasterKeyInit                     ]
    387           *
    388           * @brief       Initialize master key data.
    389           *
    390           * @param       none
    391           *
    392           * @return      none
    393           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    394          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    395          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    396            uint16 index;
    397            uint16 size;
    398          
    399            // allocate MASTER key data
    400            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    401          
    402            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A36         MOV     R2,#0x36
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000E   12....       LCALL   ??Subroutine96_0 & 0xFFFF
    403          
    404            // initialize MASTER key data
    405            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_195:
   \   000011   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000014   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000017   601F         JZ      ??ZDSecMgrMasterKeyInit_0
    406            {
    407              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   000019   7800         MOV     R0,#0x0
   \   00001B   7900         MOV     R1,#0x0
    408              {
    409                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   EA           MOV     A,R2
   \   000022   75F012       MOV     B,#0x12
   \   000025   A4           MUL     AB
   \   000026   FA           MOV     R2,A
   \   000027   ACF0         MOV     R4,B
   \   000029   75F012       MOV     B,#0x12
   \   00002C   EB           MOV     A,R3
   \   00002D   A4           MUL     AB
   \   00002E   2C           ADD     A,R4
   \   00002F   FB           MOV     R3,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000033   12....       LCALL   ?Subroutine15 & 0xFFFF
    410              }
    411            }
   \                     ??CrossCallReturnLabel_99:
   \   000036   40E5         JC      ??ZDSecMgrMasterKeyInit_1
    412          }
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   000038   02....       LJMP    ??Subroutine92_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000003   74FE         MOV     A,#-0x2
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   04           INC     A
   \   000008                REQUIRE ??Subroutine75_0
   \   000008                ; // Fall through to label ??Subroutine75_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine75_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E8           MOV     A,R0
   \   000001   2401         ADD     A,#0x1
   \   000003   08           INC     R0
   \   000004   E9           MOV     A,R1
   \   000005   3400         ADDC    A,#0x0
   \   000007   F9           MOV     R1,A
   \   000008   C3           CLR     C
   \   000009   E8           MOV     A,R0
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   E9           MOV     A,R1
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   FC           MOV     R4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3B           ADDC    A,R3
   \   000006   8C82         MOV     DPL,R4
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine84_0:
   \   000000   12....       LCALL   ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine92_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine96_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    413          //devtag.pro.security
    414          #if 0
    415          void ZDSecMgrMasterKeyInit( void )
    416          {
    417            uint16         index;
    418            uint16         size;
    419            AddrMgrEntry_t entry;
    420          
    421          
    422            // allocate MASTER key data
    423            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    424          
    425            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
    426          
    427            // initialize MASTER key data
    428            if ( ZDSecMgrMasterKeyData != NULL )
    429            {
    430              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    431              {
    432                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
    433              }
    434          
    435              // check if preconfigured keys are enabled
    436              //-------------------------------------------------------------------------
    437              #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    438              //-------------------------------------------------------------------------
    439              if ( zgPreConfigKeys == TRUE )
    440              {
    441                // sync configured data
    442                entry.user = ADDRMGR_USER_SECURITY;
    443          
    444                for ( index = 0; index < ZDSECMGR_PRECONFIG_MAX; index++ )
    445                {
    446                  // check for Address Manager entry
    447                  AddrMgrExtAddrSet( entry.extAddr,
    448                                     (uint8*)ZDSecMgrPreConfigData[index].extAddr );
    449          
    450                  if ( AddrMgrEntryLookupExt( &entry ) != TRUE )
    451                  {
    452                    // update Address Manager
    453                    AddrMgrEntryUpdate( &entry );
    454                  }
    455          
    456                  if ( entry.index != INVALID_NODE_ADDR )
    457                  {
    458                    // sync MASTER keys with Address Manager index
    459                    ZDSecMgrMasterKeyData[index].ami = entry.index;
    460          
    461                    osal_memcpy( ZDSecMgrMasterKeyData[index].key,
    462                             (void*)ZDSecMgrPreConfigData[index].key, SEC_KEY_LEN );
    463                  }
    464                }
    465              }
    466              //-------------------------------------------------------------------------
    467              #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    468              //-------------------------------------------------------------------------
    469            }
    470          }
    471          #endif
    472          
    473          /******************************************************************************
    474           * @fn          ZDSecMgrAddrStore
    475           *
    476           * @brief       Store device addresses.
    477           *
    478           * @param       nwkAddr - [in] NWK address
    479           * @param       extAddr - [in] EXT address
    480           * @param       ami     - [out] Address Manager index
    481           *
    482           * @return      ZStatus_t
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    485          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine34 & 0xFFFF
    486            ZStatus_t      status;
    487            AddrMgrEntry_t entry;
    488          
    489          
    490            // add entry
    491            entry.user    = ADDRMGR_USER_SECURITY;
    492            entry.nwkAddr = nwkAddr;
   \                     ??CrossCallReturnLabel_27:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ??Subroutine96_0 & 0xFFFF
    493            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_196:
   \   000018                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine54 & 0xFFFF
    494          
    495            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_71:
   \   000020   700A         JNZ     ??ZDSecMgrAddrStore_0
    496            {
    497              // return successful results
    498              *ami   = entry.index;
   \   000022   740B         MOV     A,#0xb
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
    499              status = ZSuccess;
    500            }
   \                     ??CrossCallReturnLabel_17:
   \   00002A   8008         SJMP    ??CrossCallReturnLabel_20
    501            else
    502            {
    503              // return failed results
    504              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00002C   740B         MOV     A,#0xb
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine26 & 0xFFFF
    505              status = ZNwkUnknownDevice;
    506            }
    507          
    508            return status;
   \                     ??CrossCallReturnLabel_20:
   \   000034   02....       LJMP    ?Subroutine7 & 0xFFFF
    509          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000003   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000006   E9           MOV     A,R1
   \   000007   6401         XRL     A,#0x1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   7402         MOV     A,#0x2
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   14           DEC     A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000003   79C8         MOV     R1,#-0x38
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000003   7900         MOV     R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8E82         MOV     DPL,R6
   \   000007   8F83         MOV     DPH,R7
   \   000009   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   740D         MOV     A,#0xd
   \   000002   02....       LJMP    ??Subroutine88_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   12....       LCALL   ??AddrMgrExtAddrSet?relay
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000007   85..82       MOV     DPL,?XSP + 0
   \   00000A   85..83       MOV     DPH,?XSP + 1
   \   00000D   AA82         MOV     R2,DPL
   \   00000F   AB83         MOV     R3,DPH
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine88_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine89_0
   \   000003                ; // Fall through to label ??Subroutine89_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine89_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    510          
    511          /******************************************************************************
    512           * @fn          ZDSecMgrExtAddrStore
    513           *
    514           * @brief       Store EXT address.
    515           *
    516           * @param       extAddr - [in] EXT address
    517           * @param       ami     - [out] Address Manager index
    518           *
    519           * @return      ZStatus_t
    520           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    521          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    522          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine34 & 0xFFFF
    523            ZStatus_t      status;
    524            AddrMgrEntry_t entry;
    525          
    526          
    527            // add entry
    528            entry.user    = ADDRMGR_USER_SECURITY;
    529            entry.nwkAddr = nwkAddr;
   \                     ??CrossCallReturnLabel_28:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ??Subroutine96_0 & 0xFFFF
    530            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_197:
   \   000018                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine54 & 0xFFFF
    531          
    532            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_72:
   \   000020   700A         JNZ     ??ZDSecMgrExtAddrStore_0
    533            {
    534              // return successful results
    535              *ami   = entry.index;
   \   000022   740B         MOV     A,#0xb
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
    536              status = ZSuccess;
    537            }
   \                     ??CrossCallReturnLabel_18:
   \   00002A   8008         SJMP    ??CrossCallReturnLabel_21
    538            else
    539            {
    540              // return failed results
    541              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00002C   740B         MOV     A,#0xb
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine26 & 0xFFFF
    542              status = ZNwkUnknownDevice;
    543            }
    544          
    545            return status;
   \                     ??CrossCallReturnLabel_21:
   \   000034   80..         SJMP    ?Subroutine7
    546          }
    547          
    548          /******************************************************************************
    549           * @fn          ZDSecMgrExtAddrLookup
    550           *
    551           * @brief       Lookup index for specified EXT address.
    552           *
    553           * @param       extAddr - [in] EXT address
    554           * @param       ami     - [out] Address Manager index
    555           *
    556           * @return      ZStatus_t
    557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    558          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    559          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    560            ZStatus_t      status;
    561            AddrMgrEntry_t entry;
    562          
    563          
    564            // lookup entry
    565            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
    566            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   12....       LCALL   ?Subroutine72 & 0xFFFF
    567          
    568            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_98:
   \   000023   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000026   E9           MOV     A,R1
   \   000027   6401         XRL     A,#0x1
   \   000029   700A         JNZ     ??ZDSecMgrExtAddrLookup_0
    569            {
    570              // return successful results
    571              *ami   = entry.index;
   \   00002B   740B         MOV     A,#0xb
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   12....       LCALL   ?Subroutine25 & 0xFFFF
    572              status = ZSuccess;
    573            }
   \                     ??CrossCallReturnLabel_19:
   \   000033   8008         SJMP    ??CrossCallReturnLabel_22
    574            else
    575            {
    576              // return failed results
    577              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000035   740B         MOV     A,#0xb
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   12....       LCALL   ?Subroutine26 & 0xFFFF
    578              status = ZNwkUnknownDevice;
    579            }
    580          
    581            return status;
   \                     ??CrossCallReturnLabel_22:
   \   00003D                REQUIRE ?Subroutine7
   \   00003D                ; // Fall through to label ?Subroutine7
    582          }
    583          
    584          /******************************************************************************
    585           * @fn          ZDSecMgrMasterKeyLookup
    586           *
    587           * @brief       Lookup MASTER key for specified address index.
    588           *
    589           * @param       ami - [in] Address Manager index
    590           * @param       key - [out] valid MASTER key
    591           *
    592           * @return      ZStatus_t
    593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    594          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key )
   \                     ZDSecMgrMasterKeyLookup:
    595          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine69 & 0xFFFF
    596            ZStatus_t status;
    597            uint16    index;
    598          
    599          
    600            // initialize results
    601            *key   = NULL;
    602            status = ZNwkUnknownDevice;
    603          
    604            // verify data is available
    605            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_110:
   \   000008   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000B   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   00000E   603F         JZ      ??ZDSecMgrMasterKeyLookup_0
    606            {
    607              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000010   7800         MOV     R0,#0x0
   \   000012   7900         MOV     R1,#0x0
    608              {
    609                if ( ZDSecMgrMasterKeyData[index].ami == ami )
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000014   E8           MOV     A,R0
   \   000015   FC           MOV     R4,A
   \   000016   E9           MOV     A,R1
   \   000017   FD           MOV     R5,A
   \   000018   EC           MOV     A,R4
   \   000019   75F012       MOV     B,#0x12
   \   00001C   A4           MUL     AB
   \   00001D   FC           MOV     R4,A
   \   00001E   85F0..       MOV     ?V0 + 1,B
   \   000021   75F012       MOV     B,#0x12
   \   000024   ED           MOV     A,R5
   \   000025   A4           MUL     AB
   \   000026   25..         ADD     A,?V0 + 1
   \   000028   FD           MOV     R5,A
   \   000029   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   2C           ADD     A,R4
   \   00002E   FC           MOV     R4,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   3D           ADDC    A,R5
   \   000032   FD           MOV     R5,A
   \   000033   8C82         MOV     DPL,R4
   \   000035   8D83         MOV     DPH,R5
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6A           XRL     A,R2
   \   000039   7003         JNZ     ??ZDSecMgrMasterKeyLookup_2
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   6B           XRL     A,R3
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   00003E   700A         JNZ     ??CrossCallReturnLabel_104
    610                {
    611                  // return successful results
    612                  *key   = ZDSecMgrMasterKeyData[index].key;
   \   000040   EC           MOV     A,R4
   \   000041   2402         ADD     A,#0x2
   \   000043   F8           MOV     R0,A
   \   000044   ED           MOV     A,R5
   \   000045   3400         ADDC    A,#0x0
   \   000047   12....       LCALL   ?Subroutine16 & 0xFFFF
    613                  status = ZSuccess;
    614          
    615                  // break from loop
    616                  index  = ZDSECMGR_MASTERKEY_MAX;
    617                }
    618              }
   \                     ??CrossCallReturnLabel_104:
   \   00004A   12....       LCALL   ?Subroutine52 & 0xFFFF
    619            }
   \                     ??CrossCallReturnLabel_63:
   \   00004D   40C5         JC      ??ZDSecMgrMasterKeyLookup_1
    620          
    621            return status;
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   00004F                REQUIRE ?Subroutine9
   \   00004F                ; // Fall through to label ?Subroutine9
    622          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   A9..         MOV     R1,?V0 + 0
   \   000002   02....       LJMP    ??Subroutine100_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   EC           MOV     A,R4
   \   000001   FE           MOV     R6,A
   \   000002   ED           MOV     A,R5
   \   000003   FF           MOV     R7,A
   \   000004   8E82         MOV     DPL,R6
   \   000006   8F83         MOV     DPH,R7
   \   000008                REQUIRE ??Subroutine76_0
   \   000008                ; // Fall through to label ??Subroutine76_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine76_0:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   F0           MOVX    @DPTR,A
   \   000004   75..C8       MOV     ?V0 + 0,#-0x38
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine77_0
   \   000005                ; // Fall through to label ??Subroutine77_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine77_0:
   \   000000   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000003   75..00       MOV     ?V0 + 0,#0x0
   \   000006   7803         MOV     R0,#0x3
   \   000008   7900         MOV     R1,#0x0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine100_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    623          
    624          /******************************************************************************
    625           * @fn          ZDSecMgrMasterKeyStore
    626           *
    627           * @brief       Store MASTER key for specified address index.
    628           *
    629           * @param       ami - [in] Address Manager index
    630           * @param       key - [in] valid key to store
    631           *
    632           * @return      ZStatus_t
    633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    634          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    635          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 4,R2
   \   000007   8B..         MOV     ?V0 + 5,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    636            ZStatus_t status;
    637            uint16    index;
    638            uint8*    entry;
    639          
    640          
    641            // initialize results
    642            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV     R4,#-0x38
    643          
    644            // verify data is available
    645            if ( ZDSecMgrMasterKeyData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000012   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000015   606C         JZ      ??ZDSecMgrMasterKeyStore_0
    646            {
    647              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000017   7800         MOV     R0,#0x0
   \   000019   7900         MOV     R1,#0x0
    648              {
    649                if ( ZDSecMgrMasterKeyData[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   00001B   E8           MOV     A,R0
   \   00001C   FA           MOV     R2,A
   \   00001D   E9           MOV     A,R1
   \   00001E   FB           MOV     R3,A
   \   00001F   EA           MOV     A,R2
   \   000020   75F012       MOV     B,#0x12
   \   000023   A4           MUL     AB
   \   000024   FA           MOV     R2,A
   \   000025   ADF0         MOV     R5,B
   \   000027   75F012       MOV     B,#0x12
   \   00002A   EB           MOV     A,R3
   \   00002B   A4           MUL     AB
   \   00002C   2D           ADD     A,R5
   \   00002D   FB           MOV     R3,A
   \   00002E   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000031   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000034   64FE         XRL     A,#0xfe
   \   000036   7003         JNZ     ??ZDSecMgrMasterKeyStore_2
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F4           CPL     A
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   00003B   7041         JNZ     ??ZDSecMgrMasterKeyStore_3
    650                {
    651                  // store EXT address index
    652                  ZDSecMgrMasterKeyData[index].ami = ami;
   \   00003D   8A82         MOV     DPL,R2
   \   00003F   8B83         MOV     DPH,R3
   \   000041   E5..         MOV     A,?V0 + 4
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   E5..         MOV     A,?V0 + 5
   \   000047   F0           MOVX    @DPTR,A
    653          
    654                  entry = ZDSecMgrMasterKeyData[index].key;
   \   000048   EA           MOV     A,R2
   \   000049   2402         ADD     A,#0x2
   \   00004B   0A           INC     R2
   \   00004C   0A           INC     R2
   \   00004D   EB           MOV     A,R3
   \   00004E   3400         ADDC    A,#0x0
   \   000050   FB           MOV     R3,A
    655          
    656                  if ( key != NULL )
   \   000051   EE           MOV     A,R6
   \   000052   4F           ORL     A,R7
   \   000053   601A         JZ      ??ZDSecMgrMasterKeyStore_4
    657                  {
    658                    osal_memcpy( entry, key,  SEC_KEY_LEN );
   \   000055                ; Setup parameters for call to function osal_memcpy
   \   000055   8E..         MOV     ?V0 + 0,R6
   \   000057   8F..         MOV     ?V0 + 1,R7
   \   000059   75..00       MOV     ?V0 + 2,#0x0
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000061   7C10         MOV     R4,#0x10
   \   000063   7D00         MOV     R5,#0x0
   \   000065   12....       LCALL   ??osal_memcpy?relay
   \   000068   7403         MOV     A,#0x3
   \   00006A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006D   8009         SJMP    ??ZDSecMgrMasterKeyStore_5
    659                  }
    660                  else
    661                  {
    662                    osal_memset( entry, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   00006F                ; Setup parameters for call to function osal_memset
   \   00006F   7C10         MOV     R4,#0x10
   \   000071   7D00         MOV     R5,#0x0
   \   000073   7900         MOV     R1,#0x0
   \   000075   12....       LCALL   ??osal_memset?relay
    663                  }
    664          
    665                  // return successful results
    666                  status = ZSuccess;
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   000078   7C00         MOV     R4,#0x0
    667          
    668                  // break from loop
    669                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   00007A   7803         MOV     R0,#0x3
   \   00007C   7900         MOV     R1,#0x0
    670                }
    671              }
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   00007E   12....       LCALL   ?Subroutine52 & 0xFFFF
    672            }
   \                     ??CrossCallReturnLabel_64:
   \   000081   4098         JC      ??ZDSecMgrMasterKeyStore_1
    673          
    674            return status;
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000083   EC           MOV     A,R4
   \   000084   F9           MOV     R1,A
   \   000085   7F06         MOV     R7,#0x6
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
    675          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3B           ADDC    A,R3
   \   000006   FB           MOV     R3,A
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   22           RET
    676          
    677          /******************************************************************************
    678           * @fn          ZDSecMgrEntryInit
    679           *
    680           * @brief       Initialize entry sub module
    681           *
    682           * @param       none
    683           *
    684           * @return      none
    685           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    686          void ZDSecMgrEntryInit( void )
   \                     ZDSecMgrEntryInit:
    687          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    688            uint16 size;
    689            uint16 index;
    690          
    691            // allocate entry data
    692            size = (short)( sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX );
    693          
    694            ZDSecMgrEntries = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A57         MOV     R2,#0x57
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000E   12....       LCALL   ??Subroutine96_0 & 0xFFFF
    695          
    696            // initialize data
    697            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_198:
   \   000011   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000014   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000017   601F         JZ      ??ZDSecMgrEntryInit_0
    698            {
    699              for( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   000019   7800         MOV     R0,#0x0
   \   00001B   7900         MOV     R1,#0x0
    700              {
    701                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_1:
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   EA           MOV     A,R2
   \   000022   75F01D       MOV     B,#0x1d
   \   000025   A4           MUL     AB
   \   000026   FA           MOV     R2,A
   \   000027   ACF0         MOV     R4,B
   \   000029   75F01D       MOV     B,#0x1d
   \   00002C   EB           MOV     A,R3
   \   00002D   A4           MUL     AB
   \   00002E   2C           ADD     A,R4
   \   00002F   FB           MOV     R3,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000033   12....       LCALL   ?Subroutine15 & 0xFFFF
    702              }
    703            }
   \                     ??CrossCallReturnLabel_100:
   \   000036   40E5         JC      ??ZDSecMgrEntryInit_1
    704            ZDSecMgrRestoreFromNV();
   \                     ??ZDSecMgrEntryInit_0:
   \   000038                ; Setup parameters for call to function ZDSecMgrRestoreFromNV
   \   000038   12....       LCALL   ??ZDSecMgrRestoreFromNV?relay
    705          }
   \   00003B   02....       LJMP    ??Subroutine92_0 & 0xFFFF
    706          
    707          /******************************************************************************
    708           * @fn          ZDSecMgrEntryLookup
    709           *
    710           * @brief       Lookup entry index using specified NWK address.
    711           *
    712           * @param       nwkAddr - [in] NWK address
    713           * @param       entry   - [out] valid entry
    714           *
    715           * @return      ZStatus_t
    716           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    717          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    718          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   12....       LCALL   ?Subroutine14 & 0xFFFF
    719            ZStatus_t      status;
    720            uint16         index;
    721            AddrMgrEntry_t addrMgrEntry;
    722          
    723          
    724            // initialize results
    725            *entry = NULL;
    726            status = ZNwkUnknownDevice;
    727          
    728            // verify data is available
    729            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_107:
   \   000010   605B         JZ      ??ZDSecMgrEntryLookup_0
    730            {
    731              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
    732              addrMgrEntry.nwkAddr = nwkAddr;
   \   00001B   14           DEC     A
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ?Subroutine13 & 0xFFFF
    733          
    734              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_162:
   \   000022   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000025   E9           MOV     A,R1
   \   000026   6401         XRL     A,#0x1
   \   000028   7043         JNZ     ??ZDSecMgrEntryLookup_0
    735              {
    736                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002A   7800         MOV     R0,#0x0
   \   00002C   7900         MOV     R1,#0x0
    737                {
    738                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   00002E   E8           MOV     A,R0
   \   00002F   FA           MOV     R2,A
   \   000030   E9           MOV     A,R1
   \   000031   FB           MOV     R3,A
   \   000032   EA           MOV     A,R2
   \   000033   75F01D       MOV     B,#0x1d
   \   000036   A4           MUL     AB
   \   000037   FA           MOV     R2,A
   \   000038   ACF0         MOV     R4,B
   \   00003A   75F01D       MOV     B,#0x1d
   \   00003D   EB           MOV     A,R3
   \   00003E   A4           MUL     AB
   \   00003F   2C           ADD     A,R4
   \   000040   FB           MOV     R3,A
   \   000041   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000044   E0           MOVX    A,@DPTR
   \   000045   2A           ADD     A,R2
   \   000046   FA           MOV     R2,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   3B           ADDC    A,R3
   \   00004A   FB           MOV     R3,A
   \   00004B   740B         MOV     A,#0xb
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   E0           MOVX    A,@DPTR
   \   000051   FC           MOV     R4,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FD           MOV     R5,A
   \   000055   8A82         MOV     DPL,R2
   \   000057   8B83         MOV     DPH,R3
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   6C           XRL     A,R4
   \   00005B   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   000060   7006         JNZ     ??CrossCallReturnLabel_105
    739                  {
    740                    // return successful results
    741                    *entry = &ZDSecMgrEntries[index];
   \   000062   EA           MOV     A,R2
   \   000063   F8           MOV     R0,A
   \   000064   EB           MOV     A,R3
   \   000065   12....       LCALL   ?Subroutine16 & 0xFFFF
    742                    status = ZSuccess;
    743          
    744                    // break from loop
    745                    index = ZDSECMGR_ENTRY_MAX;
    746                  }
    747                }
   \                     ??CrossCallReturnLabel_105:
   \   000068   12....       LCALL   ?Subroutine52 & 0xFFFF
    748              }
    749            }
   \                     ??CrossCallReturnLabel_65:
   \   00006B   40C1         JC      ??ZDSecMgrEntryLookup_1
    750          
    751            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   00006D   A9..         MOV     R1,?V0 + 0
   \   00006F                REQUIRE ?Subroutine10
   \   00006F                ; // Fall through to label ?Subroutine10
    752          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   740D         MOV     A,#0xd
   \   000002   02....       LJMP    ??Subroutine99_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   FF           MOV     R7,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine78_0
   \   000005                ; // Fall through to label ??Subroutine78_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine78_0:
   \   000000   12....       LCALL   ??Subroutine76_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000003   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000006   12....       LCALL   ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000009   E8           MOV     A,R0
   \   00000A   49           ORL     A,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000001                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004                REQUIRE ??Subroutine93_0
   \   000004                ; // Fall through to label ??Subroutine93_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine93_0:
   \   000000   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine99_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine100_0
   \   000003                ; // Fall through to label ??Subroutine100_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000003   AA82         MOV     R2,DPL
   \   000005   AB83         MOV     R3,DPH
   \   000007   22           RET
    753          
    754          /******************************************************************************
    755           * @fn          ZDSecMgrEntryLookupAMI
    756           *
    757           * @brief       Lookup entry using specified address index
    758           *
    759           * @param       ami   - [in] Address Manager index
    760           * @param       entry - [out] valid entry
    761           *
    762           * @return      ZStatus_t
    763           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    764          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    765          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    766            ZStatus_t status;
    767            uint16    index;
    768          
    769          
    770            // initialize results
    771            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   12....       LCALL   ??Subroutine78_0 & 0xFFFF
    772            status = ZNwkUnknownDevice;
    773          
    774            // verify data is available
    775            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_109:
   \   000010   6037         JZ      ??ZDSecMgrEntryLookupAMI_0
    776            {
    777              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000012   7800         MOV     R0,#0x0
   \   000014   7900         MOV     R1,#0x0
    778              {
    779                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000016   E8           MOV     A,R0
   \   000017   FA           MOV     R2,A
   \   000018   E9           MOV     A,R1
   \   000019   FB           MOV     R3,A
   \   00001A   EA           MOV     A,R2
   \   00001B   75F01D       MOV     B,#0x1d
   \   00001E   A4           MUL     AB
   \   00001F   FA           MOV     R2,A
   \   000020   85F0..       MOV     ?V0 + 1,B
   \   000023   75F01D       MOV     B,#0x1d
   \   000026   EB           MOV     A,R3
   \   000027   A4           MUL     AB
   \   000028   25..         ADD     A,?V0 + 1
   \   00002A   FB           MOV     R3,A
   \   00002B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002E   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000031   6E           XRL     A,R6
   \   000032   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000037   700B         JNZ     ??CrossCallReturnLabel_106
    780                {
    781                  // return successful results
    782                  *entry = &ZDSecMgrEntries[index];
   \   000039   EA           MOV     A,R2
   \   00003A   F8           MOV     R0,A
   \   00003B   EB           MOV     A,R3
   \   00003C   F9           MOV     R1,A
   \   00003D   8C82         MOV     DPL,R4
   \   00003F   8D83         MOV     DPH,R5
   \   000041   12....       LCALL   ??Subroutine77_0 & 0xFFFF
    783                  status = ZSuccess;
    784          
    785                  // break from loop
    786                  index = ZDSECMGR_ENTRY_MAX;
    787                }
    788              }
   \                     ??CrossCallReturnLabel_106:
   \   000044   12....       LCALL   ?Subroutine52 & 0xFFFF
    789            }
   \                     ??CrossCallReturnLabel_66:
   \   000047   40CD         JC      ??ZDSecMgrEntryLookupAMI_1
    790          
    791            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000049   02....       LJMP    ?Subroutine9 & 0xFFFF
    792          }
    793          
    794          /******************************************************************************
    795           * @fn          ZDSecMgrEntryLookupExt
    796           *
    797           * @brief       Lookup entry index using specified EXT address.
    798           *
    799           * @param       extAddr - [in] EXT address
    800           * @param       entry   - [out] valid entry
    801           *
    802           * @return      ZStatus_t
    803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    804          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    805          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine69 & 0xFFFF
    806            ZStatus_t status;
    807            uint16    ami;
    808          
    809          
    810            // initialize results
    811            *entry = NULL;
    812            status = ZNwkUnknownDevice;
    813          
    814            // lookup address index
    815            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \                     ??CrossCallReturnLabel_111:
   \   00000D                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000D   85..82       MOV     DPL,?XSP + 0
   \   000010   85..83       MOV     DPH,?XSP + 1
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001A   E9           MOV     A,R1
   \   00001B   7010         JNZ     ??ZDSecMgrEntryLookupExt_0
    816            {
    817              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   00001D                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00001D   EE           MOV     A,R6
   \   00001E   FC           MOV     R4,A
   \   00001F   EF           MOV     A,R7
   \   000020   FD           MOV     R5,A
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   12....       LCALL   ?Subroutine45 & 0xFFFF
    818            }
   \                     ??CrossCallReturnLabel_51:
   \   00002A   E9           MOV     A,R1
   \   00002B   F5..         MOV     ?V0 + 0,A
    819          
    820            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   00002D   02....       LJMP    ?Subroutine1 & 0xFFFF
    821          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A9..         MOV     R1,?V0 + 0
   \   000002                REQUIRE ??Subroutine87_0
   \   000002                ; // Fall through to label ??Subroutine87_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine87_0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine88_0
   \   000002                ; // Fall through to label ??Subroutine88_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000003   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000006   22           RET
    822          
    823          /******************************************************************************
    824           * @fn          ZDSecMgrEntryFree
    825           *
    826           * @brief       Free entry.
    827           *
    828           * @param       entry - [in] valid entry
    829           *
    830           * @return      ZStatus_t
    831           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    832          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
   \   000000   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
    833          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    834            entry->ami = INVALID_NODE_ADDR;
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   74FE         MOV     A,#-0x2
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   04           INC     A
   \   00000D                REQUIRE ??Subroutine91_0
   \   00000D                ; // Fall through to label ??Subroutine91_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine91_0:
   \   000000   F0           MOVX    @DPTR,A
    835          }
   \   000001                REQUIRE ??Subroutine92_0
   \   000001                ; // Fall through to label ??Subroutine92_0
    836          
    837          /******************************************************************************
    838           * @fn          ZDSecMgrEntryNew
    839           *
    840           * @brief       Get a new entry.
    841           *
    842           * @param       entry - [out] valid entry
    843           *
    844           * @return      ZStatus_t
    845           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    846          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    847          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   12....       LCALL   ?Subroutine14 & 0xFFFF
    848            ZStatus_t status;
    849            uint16    index;
    850          
    851          
    852            // initialize results
    853            *entry = NULL;
    854            status = ZNwkUnknownDevice;
    855          
    856            // verify data is available
    857            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_108:
   \   00000B   6067         JZ      ??ZDSecMgrEntryNew_0
    858            {
    859              // find available entry
    860              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000D   7A00         MOV     R2,#0x0
   \   00000F   7B00         MOV     R3,#0x0
    861              {
    862                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   000011   EA           MOV     A,R2
   \   000012   F8           MOV     R0,A
   \   000013   EB           MOV     A,R3
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   75F01D       MOV     B,#0x1d
   \   000019   A4           MUL     AB
   \   00001A   F8           MOV     R0,A
   \   00001B   ACF0         MOV     R4,B
   \   00001D   75F01D       MOV     B,#0x1d
   \   000020   E9           MOV     A,R1
   \   000021   A4           MUL     AB
   \   000022   2C           ADD     A,R4
   \   000023   F9           MOV     R1,A
   \   000024   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000027   E0           MOVX    A,@DPTR
   \   000028   28           ADD     A,R0
   \   000029   FC           MOV     R4,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   39           ADDC    A,R1
   \   00002D   FD           MOV     R5,A
   \   00002E   8C82         MOV     DPL,R4
   \   000030   8D83         MOV     DPH,R5
   \   000032   E0           MOVX    A,@DPTR
   \   000033   64FE         XRL     A,#0xfe
   \   000035   7003         JNZ     ??ZDSecMgrEntryNew_2
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F4           CPL     A
   \                     ??ZDSecMgrEntryNew_2:
   \   00003A   7027         JNZ     ??ZDSecMgrEntryNew_3
    863                {
    864                  // return successful result
    865                  *entry = &ZDSecMgrEntries[index];
   \   00003C   EC           MOV     A,R4
   \   00003D   FA           MOV     R2,A
   \   00003E   ED           MOV     A,R5
   \   00003F   FB           MOV     R3,A
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   12....       LCALL   ??Subroutine96_0 & 0xFFFF
    866                  status = ZSuccess;
   \                     ??CrossCallReturnLabel_199:
   \   000047   75..00       MOV     ?V0 + 0,#0x0
    867          
    868                  // Set the authentication option to default
    869                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00004A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   28           ADD     A,R0
   \   00004F   F8           MOV     R0,A
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   39           ADDC    A,R1
   \   000053   F9           MOV     R1,A
   \   000054   E8           MOV     A,R0
   \   000055   241C         ADD     A,#0x1c
   \   000057   F582         MOV     DPL,A
   \   000059   E9           MOV     A,R1
   \   00005A   3400         ADDC    A,#0x0
   \   00005C   F583         MOV     DPH,A
   \   00005E   E4           CLR     A
   \   00005F   F0           MOVX    @DPTR,A
    870          
    871                  // break from loop
    872                  index = ZDSECMGR_ENTRY_MAX;
   \   000060   7A03         MOV     R2,#0x3
   \   000062   FB           MOV     R3,A
    873                }
    874              }
   \                     ??ZDSecMgrEntryNew_3:
   \   000063   EA           MOV     A,R2
   \   000064   2401         ADD     A,#0x1
   \   000066   0A           INC     R2
   \   000067   EB           MOV     A,R3
   \   000068   3400         ADDC    A,#0x0
   \   00006A   FB           MOV     R3,A
   \   00006B   C3           CLR     C
   \   00006C   EA           MOV     A,R2
   \   00006D   9403         SUBB    A,#0x3
   \   00006F   EB           MOV     A,R3
   \   000070   9400         SUBB    A,#0x0
   \   000072   409D         JC      ??ZDSecMgrEntryNew_1
    875            }
    876          
    877            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   000074   02....       LJMP    ?Subroutine9 & 0xFFFF
    878          }
    879          
    880          /******************************************************************************
    881           * @fn          ZDSecMgrCtrlInit
    882           *
    883           * @brief       Initialize control sub module
    884           *
    885           * @param       none
    886           *
    887           * @return      none
    888           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    889          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    890          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    891            uint16 size;
    892            uint16 index;
    893          
    894            // allocate entry data
    895            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    896          
    897            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV     R2,#0x15
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000E   12....       LCALL   ??Subroutine96_0 & 0xFFFF
    898          
    899            // initialize data
    900            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_200:
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000017   6028         JZ      ??ZDSecMgrCtrlInit_0
    901            {
    902              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7800         MOV     R0,#0x0
   \   00001B   7900         MOV     R1,#0x0
    903              {
    904                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_1:
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   EA           MOV     A,R2
   \   000022   75F007       MOV     B,#0x7
   \   000025   A4           MUL     AB
   \   000026   FA           MOV     R2,A
   \   000027   ACF0         MOV     R4,B
   \   000029   75F007       MOV     B,#0x7
   \   00002C   EB           MOV     A,R3
   \   00002D   A4           MUL     AB
   \   00002E   2C           ADD     A,R4
   \   00002F   FB           MOV     R3,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000033   12....       LCALL   ?Subroutine64 & 0xFFFF
    905              }
    906            }
   \                     ??CrossCallReturnLabel_87:
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E4           CLR     A
   \   00003C   12....       LCALL   ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   00003F   40DC         JC      ??ZDSecMgrCtrlInit_1
    907          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   000041   02....       LJMP    ??Subroutine92_0 & 0xFFFF
    908          
    909          /******************************************************************************
    910           * @fn          ZDSecMgrCtrlRelease
    911           *
    912           * @brief       Release control data.
    913           *
    914           * @param       ctrl - [in] valid control data
    915           *
    916           * @return      none
    917           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    918          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    919          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    920            // should always be enough entry control data
    921            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   E4           CLR     A
   \   00000E   02....       LJMP    ??Subroutine91_0 & 0xFFFF
    922          }
    923          
    924          /******************************************************************************
    925           * @fn          ZDSecMgrCtrlLookup
    926           *
    927           * @brief       Lookup control data.
    928           *
    929           * @param       entry - [in] valid entry data
    930           * @param       ctrl  - [out] control data - NULL if not found
    931           *
    932           * @return      none
    933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    934          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    935          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    936            uint16 index;
    937          
    938          
    939            // initialize search results
    940            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    941          
    942            // verify data is available
    943            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000017   6046         JZ      ??ZDSecMgrCtrlLookup_0
    944            {
    945              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7800         MOV     R0,#0x0
   \   00001B   7900         MOV     R1,#0x0
    946              {
    947                // make sure control data is in use
    948                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   EA           MOV     A,R2
   \   000022   75F007       MOV     B,#0x7
   \   000025   A4           MUL     AB
   \   000026   FA           MOV     R2,A
   \   000027   85F0..       MOV     ?V0 + 0,B
   \   00002A   75F007       MOV     B,#0x7
   \   00002D   EB           MOV     A,R3
   \   00002E   A4           MUL     AB
   \   00002F   25..         ADD     A,?V0 + 0
   \   000031   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000034   6024         JZ      ??ZDSecMgrCtrlLookup_2
    949                {
    950                  // check for entry match
    951                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000036   8A82         MOV     DPL,R2
   \   000038   8B83         MOV     DPH,R3
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0 + 0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F5..         MOV     ?V0 + 1,A
   \   000041   EE           MOV     A,R6
   \   000042   65..         XRL     A,?V0 + 0
   \   000044   7003         JNZ     ??ZDSecMgrCtrlLookup_3
   \   000046   EF           MOV     A,R7
   \   000047   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000049   700F         JNZ     ??ZDSecMgrCtrlLookup_2
    952                  {
    953                    // return this control data
    954                    *ctrl = &ZDSecMgrCtrlData[index];
   \   00004B   EA           MOV     A,R2
   \   00004C   F8           MOV     R0,A
   \   00004D   EB           MOV     A,R3
   \   00004E   F9           MOV     R1,A
   \   00004F   8C82         MOV     DPL,R4
   \   000051   8D83         MOV     DPH,R5
   \   000053   12....       LCALL   ??Subroutine95_0 & 0xFFFF
    955          
    956                    // break from loop
    957                    index = ZDSECMGR_CTRL_MAX;
   \                     ??CrossCallReturnLabel_178:
   \   000056   7803         MOV     R0,#0x3
   \   000058   7900         MOV     R1,#0x0
    958                  }
    959                }
    960              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   00005A   12....       LCALL   ?Subroutine52 & 0xFFFF
    961            }
   \                     ??CrossCallReturnLabel_67:
   \   00005D   40BE         JC      ??ZDSecMgrCtrlLookup_1
    962          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   00005F   02....       LJMP    ??Subroutine100_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   FB           MOV     R3,A
   \   000001   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000004   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine95_0:
   \   000000   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   000003   22           RET
    963          
    964          /******************************************************************************
    965           * @fn          ZDSecMgrCtrlSet
    966           *
    967           * @brief       Set control data.
    968           *
    969           * @param       device - [in] valid device data
    970           * @param       entry  - [in] valid entry data
    971           * @param       ctrl   - [in] valid control data
    972           *
    973           * @return      none
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
    976                                ZDSecMgrEntry_t*  entry,
    977                                ZDSecMgrCtrl_t*   ctrl )
    978          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ??Subroutine102_0 & 0xFFFF
    979            // set control date
    980            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_221:
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   EE           MOV     A,R6
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   EF           MOV     A,R7
   \   00001E   12....       LCALL   ?Subroutine22 & 0xFFFF
    981            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_11:
   \   000021   E0           MOVX    A,@DPTR
   \   000022   8882         MOV     DPL,R0
   \   000024   8983         MOV     DPH,R1
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   F0           MOVX    @DPTR,A
    982            ctrl->entry      = entry;
   \   00002B   8882         MOV     DPL,R0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   EC           MOV     A,R4
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   ED           MOV     A,R5
   \   000033   12....       LCALL   ?Subroutine24 & 0xFFFF
    983            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \                     ??CrossCallReturnLabel_15:
   \   000036   7401         MOV     A,#0x1
   \   000038   12....       LCALL   ?Subroutine24 & 0xFFFF
    984            ctrl->cntr       = 0;
   \                     ??CrossCallReturnLabel_16:
   \   00003B   A3           INC     DPTR
   \   00003C   E4           CLR     A
   \   00003D   12....       LCALL   ?Subroutine22 & 0xFFFF
    985          
    986            // set device pointer
    987            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_12:
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   12....       LCALL   ??Subroutine95_0 & 0xFFFF
    988          }
   \                     ??CrossCallReturnLabel_179:
   \   000045   02....       LJMP    ??Subroutine89_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005                ; Setup parameters for call to function SSP_GetTrueRand
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithExt
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000   12....       LCALL   ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000003   22           RET
    989          
    990          /******************************************************************************
    991           * @fn          ZDSecMgrCtrlAdd
    992           *
    993           * @brief       Add control data.
    994           *
    995           * @param       device - [in] valid device data
    996           * @param       entry  - [in] valid entry data
    997           *
    998           * @return      ZStatus_t
    999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1000          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1001          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1002            ZStatus_t status;
   1003            uint16    index;
   1004          
   1005          
   1006            // initialize results
   1007            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV     R4,#-0x38
   1008          
   1009            // verify data is available
   1010            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000012   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000015   603F         JZ      ??ZDSecMgrCtrlAdd_0
   1011            {
   1012              // look for an empty slot
   1013              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000017   7800         MOV     R0,#0x0
   \   000019   7900         MOV     R1,#0x0
   1014              {
   1015                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_1:
   \   00001B   E8           MOV     A,R0
   \   00001C   FA           MOV     R2,A
   \   00001D   E9           MOV     A,R1
   \   00001E   FB           MOV     R3,A
   \   00001F   EA           MOV     A,R2
   \   000020   75F007       MOV     B,#0x7
   \   000023   A4           MUL     AB
   \   000024   FA           MOV     R2,A
   \   000025   ADF0         MOV     R5,B
   \   000027   75F007       MOV     B,#0x7
   \   00002A   EB           MOV     A,R3
   \   00002B   A4           MUL     AB
   \   00002C   2D           ADD     A,R5
   \   00002D   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000030   701F         JNZ     ??ZDSecMgrCtrlAdd_2
   1016                {
   1017                  // return successful results
   1018                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000032                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000032   8A..         MOV     ?V0 + 2,R2
   \   000034   8B..         MOV     ?V0 + 3,R3
   \   000036   78..         MOV     R0,#?V0 + 2
   \   000038   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003B   EE           MOV     A,R6
   \   00003C   FC           MOV     R4,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FD           MOV     R5,A
   \   00003F   AA..         MOV     R2,?V0 + 0
   \   000041   AB..         MOV     R3,?V0 + 1
   \   000043   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000046   7402         MOV     A,#0x2
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   1019          
   1020                  status = ZSuccess;
   \   00004B   7C00         MOV     R4,#0x0
   1021          
   1022                  // break from loop
   1023                  index = ZDSECMGR_CTRL_MAX;
   \   00004D   7803         MOV     R0,#0x3
   \   00004F   7900         MOV     R1,#0x0
   1024                }
   1025              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   000051   12....       LCALL   ?Subroutine52 & 0xFFFF
   1026            }
   \                     ??CrossCallReturnLabel_68:
   \   000054   40C5         JC      ??ZDSecMgrCtrlAdd_1
   1027          
   1028            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   000056   EC           MOV     A,R4
   \   000057   F9           MOV     R1,A
   \   000058   02....       LJMP    ??Subroutine105_0 & 0xFFFF
   1029          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1030          
   1031          /******************************************************************************
   1032           * @fn          ZDSecMgrCtrlTerm
   1033           *
   1034           * @brief       Terminate device control.
   1035           *
   1036           * @param       entry - [in] valid entry data
   1037           *
   1038           * @return      none
   1039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1040          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1041          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1042            ZDSecMgrCtrl_t* ctrl;
   1043          
   1044            // remove device from control data
   1045            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   12....       LCALL   ??Subroutine82_0 & 0xFFFF
   1046          
   1047            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_125:
   \   000016   6013         JZ      ??ZDSecMgrCtrlTerm_0
   1048            {
   1049              ZDSecMgrCtrlRelease ( ctrl );
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F583         MOV     DPH,A
   \   000022   8882         MOV     DPL,R0
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E4           CLR     A
   \   00002A   F0           MOVX    @DPTR,A
   1050            }
   1051          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   00002B   7402         MOV     A,#0x2
   \   00002D   80..         SJMP    ??Subroutine79_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine79_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine92_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine82_0:
   \   000000   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   \   000003                REQUIRE ??Subroutine83_0
   \   000003                ; // Fall through to label ??Subroutine83_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine83_0:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine84_0
   \   000006                ; // Fall through to label ??Subroutine84_0
   1052          
   1053          /******************************************************************************
   1054           * @fn          ZDSecMgrCtrlReset
   1055           *
   1056           * @brief       Reset control data.
   1057           *
   1058           * @param       device - [in] valid device data
   1059           * @param       entry  - [in] valid entry data
   1060           *
   1061           * @return      ZStatus_t
   1062           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1063          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1064          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1065            ZStatus_t       status;
   1066            ZDSecMgrCtrl_t* ctrl;
   1067          
   1068          
   1069            // initialize results
   1070            status = ZNwkUnknownDevice;
   1071          
   1072            // look for a match for the entry
   1073            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   12....       LCALL   ?Subroutine31 & 0xFFFF
   1074          
   1075            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_123:
   \   000022   601D         JZ      ??ZDSecMgrCtrlReset_0
   1076            {
   1077              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000024                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00002D   EE           MOV     A,R6
   \   00002E   FC           MOV     R4,A
   \   00002F   EF           MOV     A,R7
   \   000030   FD           MOV     R5,A
   \   000031   AA..         MOV     R2,?V0 + 0
   \   000033   AB..         MOV     R3,?V0 + 1
   \   000035   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000038   7402         MOV     A,#0x2
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   1078          
   1079              status = ZSuccess;
   \   00003D   7900         MOV     R1,#0x0
   \   00003F   800B         SJMP    ??ZDSecMgrCtrlReset_1
   1080            }
   1081            else
   1082            {
   1083              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   000041                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   000041   EE           MOV     A,R6
   \   000042   FC           MOV     R4,A
   \   000043   EF           MOV     A,R7
   \   000044   FD           MOV     R5,A
   \   000045   AA..         MOV     R2,?V0 + 0
   \   000047   AB..         MOV     R3,?V0 + 1
   \   000049   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   1084            }
   1085          
   1086            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   00004C   02....       LJMP    ??Subroutine98_0 & 0xFFFF
   1087          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   FB           MOV     R3,A
   \   000001                REQUIRE ??Subroutine82_0
   \   000001                ; // Fall through to label ??Subroutine82_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine98_0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine99_0
   \   000002                ; // Fall through to label ??Subroutine99_0
   1088          
   1089          /******************************************************************************
   1090           * @fn          ZDSecMgrMasterKeyLoad
   1091           *
   1092           * @brief       Load the MASTER key for device with specified EXT
   1093           *              address.
   1094           *
   1095           * @param       extAddr - [in] EXT address of device
   1096           * @param       key     - [in] MASTER key shared with device
   1097           *
   1098           * @return      ZStatus_t
   1099           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1100          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1101          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1102            ZStatus_t status;
   1103            uint8*    loaded;
   1104            uint16    ami;
   1105          
   1106          
   1107            // set status based on policy
   1108            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   1109          
   1110            if ( status == ZSuccess )
   \   00001E   7036         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1111            {
   1112              // get the address index
   1113              if ( ZDSecMgrMasterKeyLookup( ami, &loaded ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000028   7022         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1114              {
   1115                // overwrite old key
   1116                osal_memcpy( loaded, key, SEC_KEY_LEN );
   \   00002A                ; Setup parameters for call to function osal_memcpy
   \   00002A   8E..         MOV     ?V0 + 4,R6
   \   00002C   8F..         MOV     ?V0 + 5,R7
   \   00002E   75..00       MOV     ?V0 + 6,#0x0
   \   000031   78..         MOV     R0,#?V0 + 4
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000036   7C10         MOV     R4,#0x10
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7405         MOV     A,#0x5
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ??Subroutine86_0 & 0xFFFF
   1117              }
   \                     ??CrossCallReturnLabel_143:
   \   000042   12....       LCALL   ??osal_memcpy?relay
   \   000045   7403         MOV     A,#0x3
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004A   800A         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1118              else
   1119              {
   1120                // store new key -- NULL will zero key
   1121                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00004C                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00004C   EE           MOV     A,R6
   \   00004D   FC           MOV     R4,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FD           MOV     R5,A
   \   000050   12....       LCALL   ?Subroutine47 & 0xFFFF
   1122              }
   1123            }
   \                     ??CrossCallReturnLabel_55:
   \   000053   E9           MOV     A,R1
   \   000054   F5..         MOV     ?V0 + 0,A
   1124          
   1125            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000056   A9..         MOV     R1,?V0 + 0
   \   000058   7404         MOV     A,#0x4
   \   00005A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005D   7F07         MOV     R7,#0x7
   \   00005F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1126          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine86_0:
   \   000000   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   85..82       MOV     DPL,?XSP + 0
   \   000007   85..83       MOV     DPH,?XSP + 1
   \   00000A   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00000D   E9           MOV     A,R1
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000009   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000008   22           RET
   1127          
   1128          /******************************************************************************
   1129           * @fn          ZDSecMgrAppKeyGet
   1130           *
   1131           * @brief       get an APP key - option APP(MASTER or LINK) key
   1132           *
   1133           * @param       initNwkAddr - [in] NWK address of initiator device
   1134           * @param       initExtAddr - [in] EXT address of initiator device
   1135           * @param       partNwkAddr - [in] NWK address of partner device
   1136           * @param       partExtAddr - [in] EXT address of partner device
   1137           * @param       key         - [out] APP(MASTER or LINK) key
   1138           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1139           *
   1140           * @return      ZStatus_t
   1141           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1142          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1143                                                           // to KEY_TYPE_APP_LINK since
   1144                                                           // only specific requirement
   1145                                                           // right now comes from SE profile
   1146          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1147          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1148                                       uint8*  initExtAddr,
   1149                                       uint16  partNwkAddr,
   1150                                       uint8*  partExtAddr,
   1151                                       uint8** key,
   1152                                       uint8*  keyType )
   1153          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   740D         MOV     A,#0xd
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   00000D   740F         MOV     A,#0xf
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine46 & 0xFFFF
   1154            // Intentionally unreferenced parameters
   1155            (void)initNwkAddr;
   1156            (void)initExtAddr;
   1157            (void)partNwkAddr;
   1158            (void)partExtAddr;
   1159            
   1160            //---------------------------------------------------------------------------
   1161            // note:
   1162            // should use a robust mechanism to generate keys, for example
   1163            // combine EXT addresses and call a hash function
   1164            //---------------------------------------------------------------------------
   1165            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \                     ??CrossCallReturnLabel_53:
   \   000015   12....       LCALL   ??Subroutine86_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000018   7910         MOV     R1,#0x10
   \   00001A   12....       LCALL   ??SSP_GetTrueRand?relay
   1166          
   1167            *keyType = ZDSecMgrAppKeyType;
   \   00001D   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000020   E0           MOVX    A,@DPTR
   \   000021   8E82         MOV     DPL,R6
   \   000023   8F83         MOV     DPH,R7
   \   000025   F0           MOVX    @DPTR,A
   1168          
   1169            return ZSuccess;
   \   000026   7900         MOV     R1,#0x0
   \   000028   02....       LJMP    ??Subroutine89_0 & 0xFFFF
   1170          }
   1171          
   1172          /******************************************************************************
   1173           * @fn          ZDSecMgrAppKeyReq
   1174           *
   1175           * @brief       Process request for APP key between two devices.
   1176           *
   1177           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1178           *
   1179           * @return      none
   1180           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1181          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1182          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1183            APSME_TransportKeyReq_t req;
   1184            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1185            uint16                  partNwkAddr;
   1186            uint8                   key[SEC_KEY_LEN];
   1187          
   1188          
   1189            // validate initiator and partner
   1190            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1191                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EE           MOV     A,R6
   \   00000F   2405         ADD     A,#0x5
   \   000011   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   AA..         MOV     R2,?V0 + 0
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001E   E9           MOV     A,R1
   \   00001F   6401         XRL     A,#0x1
   \   000021   6003         JZ      $+5
   \   000023   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000026   EE           MOV     A,R6
   \   000027   2402         ADD     A,#0x2
   \   000029   0E           INC     R6
   \   00002A   0E           INC     R6
   \   00002B   EF           MOV     A,R7
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FF           MOV     R7,A
   \   00002F                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002F   740F         MOV     A,#0xf
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   AC82         MOV     R4,DPL
   \   000036   AD83         MOV     R5,DPH
   \   000038   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   00003B   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   00003E   E9           MOV     A,R1
   \   00003F   6401         XRL     A,#0x1
   \   000041   6003         JZ      $+5
   \   000043   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1192            {
   1193              // point the key to some memory
   1194              req.key = key;
   \   000046   7417         MOV     A,#0x17
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   A882         MOV     R0,DPL
   \   00004D   A983         MOV     R1,DPH
   \   00004F   7406         MOV     A,#0x6
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   1195          
   1196              // get an APP key - option APP (MASTER or LINK) key
   1197              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1198                                      initExtAddr,
   1199                                      partNwkAddr,
   1200                                      ind->partExtAddr,
   1201                                      &req.key,
   1202                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_180:
   \   000057                ; Setup parameters for call to function SSP_GetTrueRand
   \   000057   7417         MOV     A,#0x17
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   AA82         MOV     R2,DPL
   \   00005E   AB83         MOV     R3,DPH
   \   000060   7910         MOV     R1,#0x10
   \   000062   12....       LCALL   ??SSP_GetTrueRand?relay
   \   000065   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000068   E0           MOVX    A,@DPTR
   \   000069   C0E0         PUSH    A
   \   00006B   7404         MOV     A,#0x4
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   D0E0         POP     A
   \   000072   F0           MOVX    @DPTR,A
   1203              {
   1204                // always secure
   1205                req.nwkSecure = TRUE;
   \   000073   740C         MOV     A,#0xc
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   7401         MOV     A,#0x1
   \   00007A   F0           MOVX    @DPTR,A
   1206                req.apsSecure = TRUE;
   \   00007B   740B         MOV     A,#0xb
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   7401         MOV     A,#0x1
   \   000082   F0           MOVX    @DPTR,A
   1207                req.tunnel    = NULL;
   \   000083   740D         MOV     A,#0xd
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   E4           CLR     A
   \   000089   F0           MOVX    @DPTR,A
   \   00008A   A3           INC     DPTR
   \   00008B   12....       LCALL   ?Subroutine30 & 0xFFFF
   1208          
   1209                // send key to initiator device
   1210                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_23:
   \   00008E   F9           MOV     R1,A
   \   00008F   7402         MOV     A,#0x2
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   1211                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_181:
   \   000097   7408         MOV     A,#0x8
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   E5..         MOV     A,?V0 + 0
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E5..         MOV     A,?V0 + 1
   \   0000A2   F0           MOVX    @DPTR,A
   1212                req.initiator = TRUE;
   \   0000A3   740A         MOV     A,#0xa
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   7401         MOV     A,#0x1
   \   0000AA   F0           MOVX    @DPTR,A
   1213                APSME_TransportKeyReq( &req );
   \   0000AB                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000AB   04           INC     A
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   AA82         MOV     R2,DPL
   \   0000B1   AB83         MOV     R3,DPH
   \   0000B3   12....       LCALL   ??APSME_TransportKeyReq?relay
   1214          
   1215                // send key to partner device
   1216                req.dstAddr   = partNwkAddr;
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   0000BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C2   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   1217                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_182:
   \   0000C5   740F         MOV     A,#0xf
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   A882         MOV     R0,DPL
   \   0000CC   A983         MOV     R1,DPH
   \   0000CE   7408         MOV     A,#0x8
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   1218                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_209:
   \   0000D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D9   E4           CLR     A
   \   0000DA   F0           MOVX    @DPTR,A
   1219          
   1220                APSME_TransportKeyReq( &req );
   \   0000DB                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000DB   7402         MOV     A,#0x2
   \   0000DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E0   AA82         MOV     R2,DPL
   \   0000E2   AB83         MOV     R3,DPH
   \   0000E4   12....       LCALL   ??APSME_TransportKeyReq?relay
   1221              }
   1222            }
   1223          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000E7   7427         MOV     A,#0x27
   \   0000E9   02....       LJMP    ??Subroutine99_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F8           MOV     R0,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine86_0
   \   000004                ; // Fall through to label ??Subroutine86_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   F5..         MOV     ?V0 + 0,A
   \   000002   EF           MOV     A,R7
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000007                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000007   85..82       MOV     DPL,?XSP + 0
   \   00000A   85..83       MOV     DPH,?XSP + 1
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine97_0:
   \   000000   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV     A,#0xa
   \   000005   22           RET
   1224          
   1225          /******************************************************************************
   1226           * @fn          ZDSecMgrEstablishKey
   1227           *
   1228           * @brief       Start SKKE with device joining network.
   1229           *
   1230           * @param       device - [in] ZDSecMgrDevice_t, device info
   1231           *
   1232           * @return      ZStatus_t
   1233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1234          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1235          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1236            ZStatus_t               status;
   1237            APSME_EstablishKeyReq_t req;
   1238          
   1239          
   1240            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   1241            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_183:
   \   00001D   7404         MOV     A,#0x4
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
   1242          
   1243            if ( device->parentAddr == NLME_GetShortAddr() )
   \   000024                ; Setup parameters for call to function NLME_GetShortAddr
   \   000024   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000027   EA           MOV     A,R2
   \   000028   68           XRL     A,R0
   \   000029   7002         JNZ     ??ZDSecMgrEstablishKey_0
   \   00002B   EB           MOV     A,R3
   \   00002C   69           XRL     A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   00002D   7017         JNZ     ??ZDSecMgrEstablishKey_1
   1244            {
   1245              req.dstAddr   = device->nwkAddr;
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000036   12....       LCALL   ?Subroutine27 & 0xFFFF
   1246              //devtag.0604.todo - remove obsolete
   1247              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_113:
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E4           CLR     A
   \   00003D   F0           MOVX    @DPTR,A
   1248              req.nwkSecure = FALSE;
   \   00003E   7406         MOV     A,#0x6
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   E4           CLR     A
   \   000044   8010         SJMP    ??ZDSecMgrEstablishKey_2
   1249            }
   1250            else
   1251            {
   1252              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000046   12....       LCALL   ?Subroutine27 & 0xFFFF
   1253              //devtag.0604.todo - remove obsolete
   1254              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_114:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   7401         MOV     A,#0x1
   \   00004E   F0           MOVX    @DPTR,A
   1255              req.nwkSecure = TRUE;
   \   00004F   7406         MOV     A,#0x6
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   7401         MOV     A,#0x1
   1256            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000056   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   1257          
   1258            status = APSME_EstablishKeyReq( &req );
   1259          
   1260            return status;
   \                     ??CrossCallReturnLabel_164:
   \   000059   12....       LCALL   ??APSME_EstablishKeyReq?relay
   \   00005C   7407         MOV     A,#0x7
   \   00005E   02....       LJMP    ??Subroutine99_0 & 0xFFFF
   1261          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine80_0
   \   000006                ; // Fall through to label ??Subroutine80_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine80_0:
   \   000000   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV     A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009                REQUIRE ??Subroutine101_0
   \   000009                ; // Fall through to label ??Subroutine101_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine101_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine102_0
   \   000002                ; // Fall through to label ??Subroutine102_0
   1262          
   1263          /******************************************************************************
   1264           * @fn          ZDSecMgrSendMasterKey
   1265           *
   1266           * @brief       Send MASTER key to device joining network.
   1267           *
   1268           * @param       device - [in] ZDSecMgrDevice_t, device info
   1269           *
   1270           * @return      ZStatus_t
   1271           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1272          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1273          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1274            ZStatus_t               status;
   1275            APSME_TransportKeyReq_t req;
   1276          
   1277          
   1278            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   12....       LCALL   ?Subroutine20 & 0xFFFF
   1279            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_7:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   1280            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_184:
   \   00001D   740B         MOV     A,#0xb
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   F0           MOVX    @DPTR,A
   1281          
   1282            ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &req.key );
   \   000026                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   AC82         MOV     R4,DPL
   \   00002D   AD83         MOV     R5,DPH
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00003E   F583         MOV     DPH,A
   \   000040   8882         MOV     DPL,R0
   \   000042   12....       LCALL   ?Subroutine48 & 0xFFFF
   1283          
   1284            //check if using secure hop to to parent
   1285            if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_57:
   \   000045                ; Setup parameters for call to function NLME_GetShortAddr
   \   000045   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000048   EA           MOV     A,R2
   \   000049   68           XRL     A,R0
   \   00004A   7002         JNZ     ??ZDSecMgrSendMasterKey_0
   \   00004C   EB           MOV     A,R3
   \   00004D   69           XRL     A,R1
   \                     ??ZDSecMgrSendMasterKey_0:
   \   00004E   6012         JZ      ??ZDSecMgrSendMasterKey_1
   1286            {
   1287              //send to parent with security
   1288              req.dstAddr   = device->parentAddr;
   \   000050   12....       LCALL   ?Subroutine17 & 0xFFFF
   1289              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_207:
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   7401         MOV     A,#0x1
   \   000058   F0           MOVX    @DPTR,A
   1290              req.apsSecure = TRUE;
   \   000059   7409         MOV     A,#0x9
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   7401         MOV     A,#0x1
   \   000060   8015         SJMP    ??ZDSecMgrSendMasterKey_2
   1291            }
   1292            else
   1293            {
   1294              //direct with no security
   1295              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000062   8E82         MOV     DPL,R6
   \   000064   8F83         MOV     DPH,R7
   \   000066   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000069   12....       LCALL   ?Subroutine17 & 0xFFFF
   1296              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_208:
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   E4           CLR     A
   \   000070   F0           MOVX    @DPTR,A
   1297              req.apsSecure = FALSE;
   \   000071   7409         MOV     A,#0x9
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   E4           CLR     A
   1298            }
   \                     ??ZDSecMgrSendMasterKey_2:
   \   000077   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   1299          
   1300            status = APSME_TransportKeyReq( &req );
   1301          
   1302            return status;
   \                     ??CrossCallReturnLabel_165:
   \   00007A   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   00007D   02....       LJMP    ?Subroutine10 & 0xFFFF
   1303          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000008   7406         MOV     A,#0x6
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine97_0
   \   000006                ; // Fall through to label ??Subroutine97_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine103_0
   \   000002                ; // Fall through to label ??Subroutine103_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
   1304          
   1305          /******************************************************************************
   1306           * @fn          ZDSecMgrSendNwkKey
   1307           *
   1308           * @brief       Send NWK key to device joining network.
   1309           *
   1310           * @param       device - [in] ZDSecMgrDevice_t, device info
   1311           *
   1312           * @return      ZStatus_t
   1313           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1314          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1315          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1316            ZStatus_t               status;
   1317            APSME_TransportKeyReq_t req;
   1318            APSDE_FrameTunnel_t     tunnel;
   1319          
   1320            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000015   E8           MOV     A,R0
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   E9           MOV     A,R1
   \   000019   12....       LCALL   ?Subroutine20 & 0xFFFF
   1321            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_8:
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine85_0 & 0xFFFF
   1322          
   1323            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1324              req.keyType   = KEY_TYPE_NWK_HIGH;
   1325            else
   1326              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_142:
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   7401         MOV     A,#0x1
   \   000027   F0           MOVX    @DPTR,A
   1327          
   1328            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1329                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1330            {
   1331              // set values
   1332              req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   1333              req.key       = _NIB.nwkActiveKey.key;
   1334              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1335              //key isn't used to secure the frame at the APS layer -- since the receiving
   1336              //device may not have a NWK key yet
   1337              req.apsSecure = TRUE;
   1338          
   1339              // check if using secure hop to to parent
   1340              if ( device->parentAddr == NLME_GetShortAddr() )
   1341              {
   1342                req.nwkSecure = FALSE;
   1343                req.tunnel    = NULL;
   1344              }
   1345              else
   1346              {
   1347                req.nwkSecure   = TRUE;
   1348                req.tunnel      = &tunnel;
   1349                req.tunnel->tna = device->parentAddr;
   1350                req.tunnel->dea = device->extAddr;
   1351              }
   1352            }
   1353            else
   1354            {
   1355              // default values
   1356              //devtag.0604.verify
   1357              req.nwkSecure = TRUE;
   \   000028   740A         MOV     A,#0xa
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   7401         MOV     A,#0x1
   \   00002F   F0           MOVX    @DPTR,A
   1358              req.apsSecure = FALSE;
   \   000030   7409         MOV     A,#0x9
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   1359              req.tunnel    = NULL;
   \   000037   740B         MOV     A,#0xb
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E4           CLR     A
   \   00003D   F0           MOVX    @DPTR,A
   \   00003E   A3           INC     DPTR
   \   00003F   F0           MOVX    @DPTR,A
   1360          
   1361              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000040                ; Setup parameters for call to function NLME_GetShortAddr
   \   000040   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000043   8A..         MOV     ?V0 + 0,R2
   \   000045   8B..         MOV     ?V0 + 1,R3
   \   000047   A8..         MOV     R0,?V0 + 0
   \   000049   A9..         MOV     R1,?V0 + 1
   \   00004B   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   00004E   85..82       MOV     DPL,?V0 + 0
   \   000051   F583         MOV     DPH,A
   \   000053   12....       LCALL   ??Subroutine86_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000056   E8           MOV     A,R0
   \   000057   6A           XRL     A,R2
   \   000058   7002         JNZ     ??ZDSecMgrSendNwkKey_0
   \   00005A   E9           MOV     A,R1
   \   00005B   6B           XRL     A,R3
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00005C   6003         JZ      ??CrossCallReturnLabel_205
   1362              {
   1363                req.dstAddr = device->parentAddr;
   \   00005E   12....       LCALL   ?Subroutine19 & 0xFFFF
   1364              }
   1365          
   1366              // special cases
   1367              //devtag.0604.todo - modify to preconfig flag
   1368              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_205:
   \   000061   8E82         MOV     DPL,R6
   \   000063   8F83         MOV     DPH,R7
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   7038         JNZ     ??ZDSecMgrSendNwkKey_1
   1369              {
   1370                req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   \   00006E   90....       MOV     DPTR,#_NIB + 62
   \   000071   E0           MOVX    A,@DPTR
   \   000072   C0E0         PUSH    A
   \   000074   7403         MOV     A,#0x3
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   D0E0         POP     A
   \   00007B   F0           MOVX    @DPTR,A
   1371                req.key       = _NIB.nwkActiveKey.key;
   \   00007C   7404         MOV     A,#0x4
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   74..         MOV     A,#(_NIB + 63) & 0xff
   \   000083   F0           MOVX    @DPTR,A
   \   000084   A3           INC     DPTR
   \   000085   74..         MOV     A,#((_NIB + 63) >> 8) & 0xff
   \   000087   F0           MOVX    @DPTR,A
   1372          
   1373                // check if using secure hop to to parent
   1374                if ( device->parentAddr == NLME_GetShortAddr() )
   \   000088                ; Setup parameters for call to function NLME_GetShortAddr
   \   000088   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00008B   8A..         MOV     ?V0 + 2,R2
   \   00008D   8B..         MOV     ?V0 + 3,R3
   \   00008F   A8..         MOV     R0,?V0 + 2
   \   000091   A9..         MOV     R1,?V0 + 3
   \   000093   85..82       MOV     DPL,?V0 + 0
   \   000096   85..83       MOV     DPH,?V0 + 1
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   68           XRL     A,R0
   \   00009B   7003         JNZ     ??ZDSecMgrSendNwkKey_2
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000A0   7014         JNZ     ??ZDSecMgrSendNwkKey_3
   1375                {
   1376                  req.nwkSecure = FALSE;
   \   0000A2   740A         MOV     A,#0xa
   \   0000A4   800B         SJMP    ??ZDSecMgrSendNwkKey_4
   1377                }
   1378              }
   1379              else
   1380              {
   1381                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   E4           CLR     A
   \   0000AC   F0           MOVX    @DPTR,A
   \   0000AD   A3           INC     DPTR
   \   0000AE   F0           MOVX    @DPTR,A
   1382                req.keySeqNum = 0;
   \   0000AF   7403         MOV     A,#0x3
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   E4           CLR     A
   \   0000B5   F0           MOVX    @DPTR,A
   1383              }
   1384            }
   1385          
   1386            status = APSME_TransportKeyReq( &req );
   1387          
   1388            return status;
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000B6                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   AA82         MOV     R2,DPL
   \   0000BE   AB83         MOV     R3,DPH
   \   0000C0   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000C3   740D         MOV     A,#0xd
   \   0000C5   02....       LJMP    ??Subroutine104_0 & 0xFFFF
   1389          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine85_0:
   \   000000   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine96_0
   \   000006                ; // Fall through to label ??Subroutine96_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   EE           MOV     A,R6
   \   000001   2404         ADD     A,#0x4
   \   000003   F5..         MOV     ?V0 + 0,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 1,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine105_0
   \   000003                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET
   1390          
   1391          /******************************************************************************
   1392           * @fn          ZDSecMgrDeviceEntryRemove
   1393           *
   1394           * @brief       Remove device entry.
   1395           *
   1396           * @param       entry - [in] valid entry
   1397           *
   1398           * @return      none
   1399           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1400          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   \   000000   02....       LJMP    ?Subroutine0 & 0xFFFF
   1401          {
   1402            // terminate device control
   1403            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1404            {
   1405              ZDSecMgrCtrlTerm( entry );
   1406            }
   1407          
   1408            // remove device from entry data
   1409            ZDSecMgrEntryFree( entry );
   1410          
   1411            // remove EXT address
   1412            //ZDSecMgrExtAddrRelease( aiOld );
   1413          }
   1414          
   1415          /******************************************************************************
   1416           * @fn          ZDSecMgrDeviceEntryAdd
   1417           *
   1418           * @brief       Add entry.
   1419           *
   1420           * @param       device - [in] ZDSecMgrDevice_t, device info
   1421           * @param       ami    - [in] Address Manager index
   1422           *
   1423           * @return      ZStatus_t
   1424           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1425          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1426          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1427            AddrMgrEntry_t entry;
   1428          
   1429            // get the ami data
   1430            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
   1431            entry.index = ami;
   \   000017   740B         MOV     A,#0xb
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine13 & 0xFFFF
   1432          
   1433            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_163:
   \   00001F   12....       LCALL   ??AddrMgrEntryGet?relay
   1434          
   1435            // check if NWK address is same
   1436            if ( entry.nwkAddr != nwkAddr )
   \   000022   7401         MOV     A,#0x1
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6E           XRL     A,R6
   \   000029   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00002E   600F         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1437            {
   1438              // update NWK address
   1439              entry.nwkAddr = nwkAddr;
   \   000030   7401         MOV     A,#0x1
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EE           MOV     A,R6
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EF           MOV     A,R7
   \   000039   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   1440          
   1441              AddrMgrEntryUpdate( &entry );
   1442            }
   \                     ??CrossCallReturnLabel_166:
   \   00003C   12....       LCALL   ??AddrMgrEntryUpdate?relay
   1443          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00003F   02....       LJMP    ?Subroutine7 & 0xFFFF
   1444          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1445          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1446          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1447            ZStatus_t        status;
   1448            ZDSecMgrEntry_t* entry;
   1449          
   1450          
   1451            // initialize as unknown until completion
   1452            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 0,#-0x38
   1453          
   1454            device->ctrl = NULL;
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   12....       LCALL   ?Subroutine23 & 0xFFFF
   1455          
   1456            // make sure not already registered
   1457            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_13:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   12....       LCALL   ??Subroutine86_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   00002E   12....       LCALL   ??ZDSecMgrEntryLookup?relay
   \   000031   E9           MOV     A,R1
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   702F         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1458            {
   1459              // verify that address index is same
   1460              if ( entry->ami != ami )
   \   00003A   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   6E           XRL     A,R6
   \   00003F   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000044   6031         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1461              {
   1462                // remove conflicting entry
   1463                ZDSecMgrDeviceEntryRemove( entry );
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F583         MOV     DPH,A
   \   000050   8882         MOV     DPL,R0
   \   000052   74FE         MOV     A,#-0x2
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   04           INC     A
   \   000057   12....       LCALL   ?Subroutine23 & 0xFFFF
   1464          
   1465                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_14:
   \   00005A   EE           MOV     A,R6
   \   00005B   FA           MOV     R2,A
   \   00005C   EF           MOV     A,R7
   \   00005D   FB           MOV     R3,A
   \   00005E   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000061   E9           MOV     A,R1
   \   000062   7013         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1466                {
   1467                  // update NWK address
   1468                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000064                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000064   12....       LCALL   ?Subroutine36 & 0xFFFF
   1469                }
   1470              }
   1471            }
   \                     ??CrossCallReturnLabel_32:
   \   000067   800E         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1472            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   000069                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000069   AC82         MOV     R4,DPL
   \   00006B   AD83         MOV     R5,DPH
   \   00006D   EE           MOV     A,R6
   \   00006E   FA           MOV     R2,A
   \   00006F   EF           MOV     A,R7
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000074   E9           MOV     A,R1
   \   000075   60ED         JZ      ??ZDSecMgrDeviceEntryAdd_3
   1473            {
   1474              // update NWK address
   1475              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1476            }
   1477          
   1478            // check if a new entry needs to be created
   1479            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   000077   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   00007A   7021         JNZ     ??CrossCallReturnLabel_33
   1480            {
   1481              // get new entry
   1482              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00007C                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00007C   85..82       MOV     DPL,?XSP + 0
   \   00007F   85..83       MOV     DPH,?XSP + 1
   \   000082   AA82         MOV     R2,DPL
   \   000084   AB83         MOV     R3,DPH
   \   000086   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000089   E9           MOV     A,R1
   \   00008A   7014         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   1483              {
   1484                // reset entry lkd
   1485          
   1486                // finish setting up entry
   1487                entry->ami = ami;
   \   00008C   85..82       MOV     DPL,?XSP + 0
   \   00008F   85..83       MOV     DPH,?XSP + 1
   \   000092   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000095   EE           MOV     A,R6
   \   000096   F0           MOVX    @DPTR,A
   \   000097   A3           INC     DPTR
   \   000098   EF           MOV     A,R7
   \   000099   F0           MOVX    @DPTR,A
   1488          
   1489                // update NWK address
   1490                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   00009A                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00009A   12....       LCALL   ?Subroutine36 & 0xFFFF
   1491          
   1492                // enter new device into device control
   1493                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1494                {
   1495                  status = ZDSecMgrCtrlAdd( device, entry );
   1496                }
   1497                else
   1498                {
   1499                  status = ZSuccess;
   1500                }
   1501              }
   1502            }
   1503            else
   1504            {
   1505              // reset entry lkd
   1506          
   1507              // reset entry in entry control
   1508              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1509              {
   1510                status = ZDSecMgrCtrlReset( device, entry );
   1511              }
   1512              else
   1513              {
   1514                status = ZSuccess;
   \                     ??CrossCallReturnLabel_33:
   \   00009D   75..00       MOV     ?V0 + 0,#0x0
   1515              }
   1516            }
   1517          
   1518            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   0000A0   A9..         MOV     R1,?V0 + 0
   \   0000A2   02....       LJMP    ?Subroutine3 & 0xFFFF
   1519          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000009   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000003   AC82         MOV     R4,DPL
   \   000005   AD83         MOV     R5,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   EE           MOV     A,R6
   \   000006   FA           MOV     R2,A
   \   000007   EF           MOV     A,R7
   \   000008   FB           MOV     R3,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine104_0
   \   000002                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000003   22           RET
   1520          
   1521          /******************************************************************************
   1522           * @fn          ZDSecMgrDeviceCtrlHandler
   1523           *
   1524           * @brief       Device control handler.
   1525           *
   1526           * @param       device - [in] ZDSecMgrDevice_t, device info
   1527           *
   1528           * @return      none
   1529           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1530          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1531          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1532            uint8 state;
   1533            uint8 cntr;
   1534          
   1535          
   1536            state = device->ctrl->state;
   \   000005   EA           MOV     A,R2
   \   000006   2408         ADD     A,#0x8
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   FF           MOV     R7,A
   \   00000D   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 0,A
   1537            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1538          
   1539            switch ( state )
   \   000013   24FE         ADD     A,#-0x2
   \   000015   600C         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   \   000017   14           DEC     A
   \   000018   6014         JZ      ??ZDSecMgrDeviceCtrlHandler_1
   \   00001A   14           DEC     A
   \   00001B   6022         JZ      ??ZDSecMgrDeviceCtrlHandler_2
   \   00001D   24FD         ADD     A,#-0x3
   \   00001F   6018         JZ      ??ZDSecMgrDeviceCtrlHandler_3
   \   000021   8042         SJMP    ??ZDSecMgrDeviceCtrlHandler_4
   1540            {
   1541              case ZDSECMGR_CTRL_TK_MASTER:
   1542                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000023                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000023   12....       LCALL   ??ZDSecMgrSendMasterKey?relay
   \   000026   E9           MOV     A,R1
   \   000027   7016         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1543                {
   1544                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000029   75..03       MOV     ?V0 + 0,#0x3
   1545                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00002C   8011         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1546                }
   1547                break;
   1548          
   1549              case ZDSECMGR_CTRL_SKKE_INIT:
   1550                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00002E                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   00002E   12....       LCALL   ??ZDSecMgrEstablishKey?relay
   \   000031   E9           MOV     A,R1
   \   000032   700B         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1551                {
   1552                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000034   75..04       MOV     ?V0 + 0,#0x4
   \   000037   8006         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1553                }
   1554                break;
   1555          
   1556              case ZDSECMGR_CTRL_SKKE_WAIT:
   1557                // continue to wait for SKA control timeout
   1558                break;
   1559          
   1560              case ZDSECMGR_CTRL_TK_NWK:
   1561                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000039                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000039   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   00003C   E9           MOV     A,R1
   \   00003D   6026         JZ      ??ZDSecMgrDeviceCtrlHandler_4
   1562                {
   1563                  state = ZDSECMGR_CTRL_NONE;
   1564                }
   1565                break;
   1566          
   1567              default:
   1568                state = ZDSECMGR_CTRL_NONE;
   1569                break;
   1570            }
   1571          
   1572            if ( state != ZDSECMGR_CTRL_NONE )
   1573            {
   1574              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   00003F   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000042   E5..         MOV     A,?V0 + 0
   \   000044   12....       LCALL   ?Subroutine30 & 0xFFFF
   1575              device->ctrl->cntr  = cntr;
   \                     ??CrossCallReturnLabel_24:
   \   000047   F583         MOV     DPH,A
   \   000049   8882         MOV     DPL,R0
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   7401         MOV     A,#0x1
   \   000053   F0           MOVX    @DPTR,A
   1576          
   1577              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000054                ; Setup parameters for call to function osal_start_timerEx
   \   000054   7C64         MOV     R4,#0x64
   \   000056   7D00         MOV     R5,#0x0
   \   000058   7A00         MOV     R2,#0x0
   \   00005A   FB           MOV     R3,A
   \   00005B   90....       MOV     DPTR,#ZDAppTaskID
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   12....       LCALL   ??osal_start_timerEx?relay
   \   000063   8005         SJMP    ??ZDSecMgrDeviceCtrlHandler_5
   1578            }
   1579            else
   1580            {
   1581              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   000065   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000068   E4           CLR     A
   \   000069   F0           MOVX    @DPTR,A
   1582            }
   1583          }
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   00006A   02....       LJMP    ??Subroutine89_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine81_0
   \   000004                ; // Fall through to label ??Subroutine81_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine81_0:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1584          
   1585          /******************************************************************************
   1586           * @fn          ZDSecMgrDeviceCtrlSetup
   1587           *
   1588           * @brief       Setup device control.
   1589           *
   1590           * @param       device - [in] ZDSecMgrDevice_t, device info
   1591           *
   1592           * @return      ZStatus_t
   1593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1594          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1595          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1596            if ( device->ctrl != NULL )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000013   6023         JZ      ??ZDSecMgrDeviceCtrlSetup_0
   1597            {
   1598              if ( device->secure == FALSE )
   \   000015   E8           MOV     A,R0
   \   000016   2405         ADD     A,#0x5
   \   000018   F8           MOV     R0,A
   \   000019   E9           MOV     A,R1
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F9           MOV     R1,A
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   8882         MOV     DPL,R0
   \   00002A   8983         MOV     DPH,R1
   \   00002C   7004         JNZ     ??ZDSecMgrDeviceCtrlSetup_1
   1599              {
   1600                // send the master key data to the joining device
   1601                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002E   7402         MOV     A,#0x2
   \   000030   8002         SJMP    ??ZDSecMgrDeviceCtrlSetup_2
   1602              }
   1603              else
   1604              {
   1605                // start SKKE
   1606                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000032   7403         MOV     A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000034   F0           MOVX    @DPTR,A
   1607              }
   1608          
   1609              ZDSecMgrDeviceCtrlHandler( device );
   \   000035                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000035   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   1610            }
   1611          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   000038   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   1612          
   1613          /******************************************************************************
   1614           * @fn          ZDSecMgrDeviceCtrlUpdate
   1615           *
   1616           * @brief       Update control data.
   1617           *
   1618           * @param       extAddr - [in] EXT address
   1619           * @param       state   - [in] new control state
   1620           *
   1621           * @return      none
   1622           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1623          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1624          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1625            ZDSecMgrEntry_t* entry;
   1626            ZDSecMgrCtrl_t*  ctrl;
   1627          
   1628          
   1629            // lookup device entry data
   1630            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV     A,#0x2
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   AC82         MOV     R4,DPL
   \   000013   AD83         MOV     R5,DPH
   \   000015   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   1631          
   1632            if ( entry != NULL )
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000020   6043         JZ      ??ZDSecMgrDeviceCtrlUpdate_0
   1633            {
   1634              // lookup device control data
   1635              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000022                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   AC82         MOV     R4,DPL
   \   00002A   AD83         MOV     R5,DPH
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FA           MOV     R2,A
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   12....       LCALL   ?Subroutine31 & 0xFFFF
   1636          
   1637              // make sure control data is valid
   1638              if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_124:
   \   000038   602B         JZ      ??ZDSecMgrDeviceCtrlUpdate_0
   1639              {
   1640                // possible state transitions
   1641                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   E0           MOVX    A,@DPTR
   \   000041   2405         ADD     A,#0x5
   \   000043   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000046   E0           MOVX    A,@DPTR
   \   000047   6404         XRL     A,#0x4
   \   000049   701A         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1642                {
   1643                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   00004B   7405         MOV     A,#0x5
   \   00004D   6E           XRL     A,R6
   \   00004E   7004         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1644                  {
   1645                    // send the network key
   1646                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   000050   7407         MOV     A,#0x7
   \   000052   8007         SJMP    ??ZDSecMgrDeviceCtrlUpdate_2
   1647                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1648                  }
   1649                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   000054   7406         MOV     A,#0x6
   \   000056   6E           XRL     A,R6
   \   000057   700C         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1650                  {
   1651                    // force default timeout in order to cleanup control logic
   1652                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   000059   7406         MOV     A,#0x6
   1653                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1654                  }
   1655                }
   1656                // timer should be active
   1657              }
   1658            }
   \                     ??ZDSecMgrDeviceCtrlUpdate_2:
   \   00005B   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   00005E   12....       LCALL   ??Subroutine81_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000061   A3           INC     DPTR
   \   000062   7401         MOV     A,#0x1
   \   000064   F0           MOVX    @DPTR,A
   1659          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   000065                REQUIRE ?Subroutine8
   \   000065                ; // Fall through to label ?Subroutine8

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7404         MOV     A,#0x4
   \   000002   02....       LJMP    ??Subroutine88_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F9           MOV     R1,A
   \   000006   8882         MOV     DPL,R0
   \   000008   8983         MOV     DPH,R1
   \   00000A   22           RET
   1660          
   1661          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1662          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1663          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1664            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1665            {
   1666              if ( initiator == TRUE )
   1667              {
   1668                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1669              }
   1670            }
   1671          }
   \   000000   02....       LJMP    ?BRET
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceRemove
   1675           *
   1676           * @brief       Remove device from network.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      none
   1681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1682          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1683          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1684            APSME_RemoveDeviceReq_t remDevReq;
   1685            NLME_LeaveReq_t         leaveReq;
   1686            associated_devices_t*   assoc;
   1687          
   1688          
   1689            // check if parent, remove the device
   1690            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000011   8A..         MOV     ?V0 + 0,R2
   \   000013   8B..         MOV     ?V0 + 1,R3
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \   000018   F8           MOV     R0,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F9           MOV     R1,A
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FE           MOV     R6,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FF           MOV     R7,A
   \   000035   E5..         MOV     A,?V0 + 0
   \   000037   6E           XRL     A,R6
   \   000038   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00003A   E5..         MOV     A,?V0 + 1
   \   00003C   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00003D   7052         JNZ     ??ZDSecMgrDeviceRemove_1
   1691            {
   1692              // this is the parent of the device
   1693              leaveReq.extAddr        = device->extAddr;
   \   00003F   12....       LCALL   ?Subroutine28 & 0xFFFF
   1694              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_140:
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E4           CLR     A
   \   000046   F0           MOVX    @DPTR,A
   1695              leaveReq.rejoin         = FALSE;
   \   000047   7403         MOV     A,#0x3
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E4           CLR     A
   \   00004D   12....       LCALL   ?Subroutine70 & 0xFFFF
   1696          
   1697              // find child association
   1698              assoc = AssocGetWithExt( device->extAddr );
   \                     ??CrossCallReturnLabel_94:
   \   000050   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000053   8A..         MOV     ?V0 + 0,R2
   \   000055   8B..         MOV     ?V0 + 1,R3
   \   000057   A8..         MOV     R0,?V0 + 0
   \   000059   A9..         MOV     R1,?V0 + 1
   1699          
   1700              if ( ( assoc != NULL                            ) &&
   1701                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1702                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00005B   E8           MOV     A,R0
   \   00005C   49           ORL     A,R1
   \   00005D   604E         JZ      ??ZDSecMgrDeviceRemove_2
   \   00005F   8882         MOV     DPL,R0
   \   000061   8983         MOV     DPH,R1
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   14           DEC     A
   \   000069   C3           CLR     C
   \   00006A   9404         SUBB    A,#0x4
   \   00006C   503F         JNC     ??ZDSecMgrDeviceRemove_2
   1703              {
   1704                // check if associated device is authenticated
   1705                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00006E   8882         MOV     DPL,R0
   \   000070   8983         MOV     DPH,R1
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   A2E3         MOV     C,0xE0 /* A   */.3
   \   00007A   7404         MOV     A,#0x4
   \   00007C   5006         JNC     ??ZDSecMgrDeviceRemove_3
   1706                {
   1707                  leaveReq.silent = FALSE;
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E4           CLR     A
   \   000082   8005         SJMP    ??ZDSecMgrDeviceRemove_4
   1708                }
   1709                else
   1710                {
   1711                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   7401         MOV     A,#0x1
   1712                }
   1713          
   1714                NLME_LeaveReq( &leaveReq );
   1715              }
   1716            }
   \                     ??ZDSecMgrDeviceRemove_4:
   \   000089   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   00008C   12....       LCALL   ??NLME_LeaveReq?relay
   \   00008F   801C         SJMP    ??ZDSecMgrDeviceRemove_2
   1717            else
   1718            {
   1719              // this is not the parent of the device
   1720              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000091   7405         MOV     A,#0x5
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   EE           MOV     A,R6
   \   000097   F0           MOVX    @DPTR,A
   \   000098   A3           INC     DPTR
   \   000099   EF           MOV     A,R7
   \   00009A   F0           MOVX    @DPTR,A
   1721              remDevReq.childExtAddr = device->extAddr;
   \   00009B   7407         MOV     A,#0x7
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   12....       LCALL   ??Subroutine80_0 & 0xFFFF
   1722          
   1723              APSME_RemoveDeviceReq( &remDevReq );
   1724            }
   \                     ??CrossCallReturnLabel_115:
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   AA82         MOV     R2,DPL
   \   0000A8   AB83         MOV     R3,DPH
   \   0000AA   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   1725          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000AD   7409         MOV     A,#0x9
   \   0000AF   02....       LJMP    ??Subroutine99_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine85_0
   \   000006                ; // Fall through to label ??Subroutine85_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000003   12....       LCALL   ??AssocGetWithExt?relay
   \   000006   22           RET
   1726          
   1727          /******************************************************************************
   1728           * @fn          ZDSecMgrDeviceValidateSKKE
   1729           *
   1730           * @brief       Decide whether device is allowed for SKKE.
   1731           *
   1732           * @param       device - [in] ZDSecMgrDevice_t, device info
   1733           *
   1734           * @return      ZStatus_t
   1735           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1736          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1737          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1738            ZStatus_t status;
   1739            uint16    ami;
   1740            uint8*    key;
   1741          
   1742          
   1743            // get EXT address
   1744            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   12....       LCALL   ??Subroutine86_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000021   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000024   E9           MOV     A,R1
   1745          
   1746            if ( status == ZSuccess )
   \   000025   700D         JNZ     ??CrossCallReturnLabel_34
   1747            {
   1748              // get MASTER key
   1749              status = ZDSecMgrMasterKeyLookup( ami, &key );
   \   000027                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ?Subroutine35 & 0xFFFF
   1750          
   1751              if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_30:
   \   00002F   7003         JNZ     ??CrossCallReturnLabel_34
   1752              {
   1753              //  // check if initiator is Trust Center
   1754              //  if ( device->nwkAddr == APSME_TRUSTCENTER_NWKADDR )
   1755              //  {
   1756              //    // verify NWK key not sent
   1757              //    // devtag.todo
   1758              //    // temporary - add device to internal data
   1759              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1760              //  }
   1761              //  else
   1762              //  {
   1763              //    // initiator not Trust Center - End to End SKKE - set policy
   1764              //    // for accepting an SKKE initiation
   1765              //    // temporary - add device to internal data
   1766              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1767              //  }
   1768                  status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000031                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000031   12....       LCALL   ?Subroutine37 & 0xFFFF
   1769              }
   1770            }
   1771          
   1772            return status;
   \                     ??CrossCallReturnLabel_34:
   \   000034   02....       LJMP    ?Subroutine8 & 0xFFFF
   1773          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000009   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   00000C   22           RET
   1774          
   1775          /******************************************************************************
   1776           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1777           *
   1778           * @brief       Decide whether device is allowed.
   1779           *
   1780           * @param       device - [in] ZDSecMgrDevice_t, device info
   1781           *
   1782           * @return      ZStatus_t
   1783           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1784          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1785          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1786          
   1787            ZStatus_t status;
   1788            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1789          
   1790            (void)device;  // Intentionally unreferenced parameter
   1791            
   1792            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1793            // the trust center to reject any newly joining devices by sending
   1794            // Remove-device to the parents.
   1795            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1796            {
   1797              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1798            }
   1799          
   1800          
   1801          
   1802          #if 0  // Taken out because the following functionality is only used for test
   1803                 // purpose. A more efficient (above) way is used. It can be put
   1804                 // back in if customers request for a white/black list feature.
   1805                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1806          
   1807            // The following code processes the device black list (stored device list)
   1808            // If the joining device is not part of the forbidden device list
   1809            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1810            // will send Remove-device and ban the device from joining.
   1811          
   1812            uint8     index;
   1813            uint8*    restricted;
   1814          
   1815            // Look through the stored device list - used for restricted devices
   1816            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1817            {
   1818              restricted = ZDSecMgrStoredDeviceList[index];
   1819          
   1820              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1821              {
   1822                // return as unknown device in regards to validation
   1823                status = ZNwkUnknownDevice;
   1824          
   1825                // break from loop
   1826                index = ZDSECMGR_STORED_DEVICES;
   1827              }
   1828            }
   1829          
   1830          #endif
   1831          
   1832            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   1833          }
   1834          
   1835          /******************************************************************************
   1836           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1837           *
   1838           * @brief       Decide whether device is allowed.
   1839           *
   1840           * @param       device - [in] ZDSecMgrDevice_t, device info
   1841           *
   1842           * @return      ZStatus_t
   1843           */
   1844          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1845          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1846          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1847            ZStatus_t status;
   1848            uint16    ami;
   1849            uint8*    key;
   1850          
   1851          
   1852          //  // check for pre configured setting
   1853          //  if ( device->secure == TRUE )
   1854          //  {
   1855          //    // get EXT address and MASTER key
   1856          //    status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1857          //
   1858          //    if ( status == ZSuccess )
   1859          //    {
   1860          //      status = ZDSecMgrMasterKeyLookup( ami, &key );
   1861          //    }
   1862          //  }
   1863          //  else
   1864          //  {
   1865              // implement EXT address and MASTER key policy here -- the total number of
   1866              // Security Manager entries should never exceed the number of EXT addresses
   1867              // and MASTER keys available
   1868          
   1869              // set status based on policy
   1870              //status = ZNwkUnknownDevice;
   1871          
   1872              // set status based on policy
   1873              status = ZSuccess; // ZNwkUnknownDevice;
   1874          
   1875              // get key based on policy
   1876              key = ZDSecMgrTCMasterKey;
   1877          
   1878              // if policy, store new EXT address
   1879              status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000014   8582..       MOV     ?V0 + 2,DPL
   \   000017   8583..       MOV     ?V0 + 3,DPH
   \   00001A   78..         MOV     R0,#?V0 + 2
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F   85..82       MOV     DPL,?V0 + 0
   \   000022   85..83       MOV     DPH,?V0 + 1
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FC           MOV     R4,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FD           MOV     R5,A
   \   00002A   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   00002D   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?DEALLOC_XSTACK8
   \   000035   E9           MOV     A,R1
   \   000036   F5..         MOV     ?V0 + 2,A
   1880          
   1881              // set the key
   1882              ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   000038                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   000038   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   00003A   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00003C   85..82       MOV     DPL,?V0 + 0
   \   00003F   85..83       MOV     DPH,?V0 + 1
   \   000042   12....       LCALL   ??Subroutine86_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000045   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay
   1883          //  }
   1884          
   1885            // if EXT address and MASTER key available -- add device
   1886            if ( status == ZSuccess )
   \   000048   E5..         MOV     A,?V0 + 2
   \   00004A   7006         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1887            {
   1888              // add device to internal data - with control
   1889              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00004C                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00004C   12....       LCALL   ?Subroutine37 & 0xFFFF
   1890            }
   \                     ??CrossCallReturnLabel_35:
   \   00004F   E9           MOV     A,R1
   \   000050   F5..         MOV     ?V0 + 2,A
   1891          
   1892            return status;
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000052   A9..         MOV     R1,?V0 + 2
   \   000054   02....       LJMP    ?Subroutine3 & 0xFFFF
   1893          }
   1894          //devtag.pro.security
   1895          #if 0
   1896          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1897          {
   1898            ZStatus_t status;
   1899            uint16    ami;
   1900            uint8*    key;
   1901          
   1902          
   1903            // check for pre configured setting
   1904            if ( device->secure == TRUE )
   1905            {
   1906              // get EXT address and MASTER key
   1907              status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1908          
   1909              if ( status == ZSuccess )
   1910              {
   1911                status = ZDSecMgrMasterKeyLookup( ami, &key );
   1912              }
   1913            }
   1914            else
   1915            {
   1916              // implement EXT address and MASTER key policy here -- the total number of
   1917              // Security Manager entries should never exceed the number of EXT addresses
   1918              // and MASTER keys available
   1919          
   1920              // set status based on policy
   1921              status = ZSuccess; // ZNwkUnknownDevice;
   1922          
   1923              // get the address index
   1924              if ( ZDSecMgrExtAddrLookup( device->extAddr, &ami ) != ZSuccess )
   1925              {
   1926                // if policy, store new EXT address
   1927                status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1928              }
   1929          
   1930              // get the address index
   1931              if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   1932              {
   1933                // if policy, store new key -- NULL will zero key
   1934                status = ZDSecMgrMasterKeyStore( ami, NULL );
   1935              }
   1936            }
   1937          
   1938            // if EXT address and MASTER key available -- add device
   1939            if ( status == ZSuccess )
   1940            {
   1941              // add device to internal data - with control
   1942              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1943            }
   1944          
   1945            return status;
   1946          }
   1947          #endif
   1948          
   1949          /******************************************************************************
   1950           * @fn          ZDSecMgrDeviceValidate
   1951           *
   1952           * @brief       Decide whether device is allowed.
   1953           *
   1954           * @param       device - [in] ZDSecMgrDevice_t, device info
   1955           *
   1956           * @return      ZStatus_t
   1957           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1958          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1959          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1960            ZStatus_t status;
   1961          
   1962          
   1963            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   701F         JNZ     ??ZDSecMgrDeviceValidate_0
   1964            {
   1965              // device may be joining with a secure flag but it is ultimately the Trust
   1966              // Center that decides -- check if expected pre configured device --
   1967              // override settings
   1968              if ( zgPreConfigKeys == TRUE )
   \   00000C   EA           MOV     A,R2
   \   00000D   2406         ADD     A,#0x6
   \   00000F   F8           MOV     R0,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#zgPreConfigKeys
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   7004         JNZ     ??ZDSecMgrDeviceValidate_1
   1969              {
   1970                device->secure = TRUE;
   \   000020   7401         MOV     A,#0x1
   \   000022   8001         SJMP    ??ZDSecMgrDeviceValidate_2
   1971              }
   1972              else
   1973              {
   1974                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000024   E4           CLR     A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000025   F0           MOVX    @DPTR,A
   1975              }
   1976          
   1977              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1978              {
   1979                status = ZDSecMgrDeviceValidateCM( device );
   1980              }
   1981              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1982              {
   1983                status = ZDSecMgrDeviceValidateRM( device );
   \   000026                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000026   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   000029   8002         SJMP    ??ZDSecMgrDeviceValidate_3
   1984              }
   1985            }
   1986            else
   1987            {
   1988              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002B   79C8         MOV     R1,#-0x38
   1989            }
   1990          
   1991            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002D   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   1992          }
   1993          
   1994          /******************************************************************************
   1995           * @fn          ZDSecMgrDeviceJoin
   1996           *
   1997           * @brief       Try to join this device.
   1998           *
   1999           * @param       device - [in] ZDSecMgrDevice_t, device info
   2000           *
   2001           * @return      ZStatus_t
   2002           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2003          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2004          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2005            ZStatus_t status;
   2006          
   2007            // attempt to validate device
   2008            status = ZDSecMgrDeviceValidate( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   000009   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2009          
   2010            if ( status == ZSuccess )
   \   00000F   700C         JNZ     ??ZDSecMgrDeviceJoin_0
   2011            {
   2012              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2013              {
   2014                ZDSecMgrDeviceCtrlSetup( device );
   2015              }
   2016              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2017              {
   2018                //send the nwk key data to the joining device
   2019                status = ZDSecMgrSendNwkKey( device );
   \   000011                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000011   EE           MOV     A,R6
   \   000012   FA           MOV     R2,A
   \   000013   EF           MOV     A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000018   E9           MOV     A,R1
   \   000019   F5..         MOV     ?V0 + 0,A
   \   00001B   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2020              }
   2021            }
   2022            else
   2023            {
   2024              // not allowed, remove the device
   2025              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00001D                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2026            }
   2027          
   2028            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000024                REQUIRE ?Subroutine11
   \   000024                ; // Fall through to label ?Subroutine11
   2029          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   A9..         MOV     R1,?V0 + 0
   \   000002   02....       LJMP    ??Subroutine89_0 & 0xFFFF
   2030          
   2031          /******************************************************************************
   2032           * @fn          ZDSecMgrDeviceJoinDirect
   2033           *
   2034           * @brief       Try to join this device as a direct child.
   2035           *
   2036           * @param       device - [in] ZDSecMgrDevice_t, device info
   2037           *
   2038           * @return      ZStatus_t
   2039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2040          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2041          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2042            ZStatus_t status;
   2043          
   2044            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2045          
   2046            if ( status == ZSuccess )
   \   00000F   7009         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2047            {
   2048              // set association status to authenticated
   2049              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   12....       LCALL   ?Subroutine50 & 0xFFFF
   2050            }
   \                     ??CrossCallReturnLabel_152:
   \   000014   12....       LCALL   ??AssocGetWithShort?relay
   \   000017   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2051          
   2052            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001A   80..         SJMP    ?Subroutine11
   2053          }
   2054          
   2055          /******************************************************************************
   2056           * @fn          ZDSecMgrDeviceJoinFwd
   2057           *
   2058           * @brief       Forward join to Trust Center.
   2059           *
   2060           * @param       device - [in] ZDSecMgrDevice_t, device info
   2061           *
   2062           * @return      ZStatus_t
   2063           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2064          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2065          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2066            ZStatus_t               status;
   2067            APSME_UpdateDeviceReq_t req;
   2068          
   2069          
   2070            // forward any joining device to the Trust Center -- the Trust Center will
   2071            // decide if the device is allowed to join
   2072            status = ZSuccess;
   2073          
   2074            // forward authorization to the Trust Center
   2075            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   12....       LCALL   ?Subroutine70 & 0xFFFF
   2076            req.devAddr    = device->nwkAddr;
   \                     ??CrossCallReturnLabel_95:
   \   000015   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine18 & 0xFFFF
   2077            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_5:
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   2078          
   2079            // set security status, option for router to reject if policy set
   2080            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_185:
   \   000024   EA           MOV     A,R2
   \   000025   2407         ADD     A,#0x7
   \   000027   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   00002A   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002C   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2081            {
   2082              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   00002E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000030   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2083              {
   2084                if ( device->secure == TRUE )
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   6401         XRL     A,#0x1
   \   00003F   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2085                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000041   7406         MOV     A,#0x6
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   7404         MOV     A,#0x4
   \   000048   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2086                else
   2087                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00004A   7406         MOV     A,#0x6
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   7407         MOV     A,#0x7
   \   000051   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2088              }
   2089              else
   2090                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000053   7406         MOV     A,#0x6
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   7405         MOV     A,#0x5
   \   00005A   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2091            }
   2092            else
   2093            {
   2094              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   00005C   A2E6         MOV     C,0xE0 /* A   */.6
   \   00005E   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2095              {
   2096                if ( device->secure == TRUE )
   \   000060   8A82         MOV     DPL,R2
   \   000062   8B83         MOV     DPH,R3
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   6401         XRL     A,#0x1
   \   00006D   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2097                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   00006F   7406         MOV     A,#0x6
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E4           CLR     A
   \   000075   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2098                else
   2099                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000077   7406         MOV     A,#0x6
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   7403         MOV     A,#0x3
   \   00007E   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2100              }
   2101              else
   2102                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000080   7406         MOV     A,#0x6
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   000087   F0           MOVX    @DPTR,A
   2103            }
   2104          
   2105            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2106              req.apsSecure = TRUE;
   2107            else
   2108              req.apsSecure = FALSE;
   \   000088   7407         MOV     A,#0x7
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   E4           CLR     A
   \   00008E   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   2109          
   2110            // send and APSME_UPDATE_DEVICE request to the trust center
   2111            status = APSME_UpdateDeviceReq( &req );
   2112          
   2113            return status;
   \                     ??CrossCallReturnLabel_168:
   \   000091   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   000094   7408         MOV     A,#0x8
   \   000096   02....       LJMP    ??Subroutine79_0 & 0xFFFF
   2114          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   F582         MOV     DPL,A
   \   000002   EB           MOV     A,R3
   \   000003                REQUIRE ??Subroutine90_0
   \   000003                ; // Fall through to label ??Subroutine90_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine90_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000007   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   00000A   7404         MOV     A,#0x4
   \   00000C   22           RET
   2115          
   2116          /******************************************************************************
   2117           * @fn          ZDSecMgrDeviceNew
   2118           *
   2119           * @brief       Process a new device.
   2120           *
   2121           * @param       device - [in] ZDSecMgrDevice_t, device info
   2122           *
   2123           * @return      ZStatus_t
   2124           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2125          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2126          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2127            ZStatus_t status;
   2128          
   2129            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2130            {
   2131              // try to join this device
   2132              status = ZDSecMgrDeviceJoinDirect( joiner );
   2133            }
   2134            else
   2135            {
   2136              status = ZDSecMgrDeviceJoinFwd( joiner );
   2137            }
   2138          
   2139            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL   ??ZDSecMgrDeviceJoinFwd?relay
   \   000007   80..         SJMP    ??Subroutine92_0
   2140          }
   2141          
   2142          /******************************************************************************
   2143           * @fn          ZDSecMgrAssocDeviceAuth
   2144           *
   2145           * @brief       Set associated device status to authenticated
   2146           *
   2147           * @param       assoc - [in, out] associated_devices_t
   2148           *
   2149           * @return      none
   2150           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2151          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2152          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2153            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   2154            {
   2155              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   2156            }
   2157          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP    ??Subroutine92_0
   2158          
   2159          /******************************************************************************
   2160           * @fn          ZDSecMgrAuthInitiate
   2161           *
   2162           * @brief       Initiate entity authentication
   2163           *
   2164           * @param       responder - [in] responder EXT address
   2165           *
   2166           * @return      none
   2167           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2168          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2169          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2170            APSME_AuthenticateReq_t req;
   2171          
   2172          
   2173            // make sure NWK address is available
   2174            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   601F         JZ      ??ZDSecMgrAuthInitiate_0
   2175            {
   2176              // set request fields
   2177              req.extAddr   = responder;
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   F0           MOVX    @DPTR,A
   2178              req.action    = APSME_EA_INITIATE;
   \   000028   7406         MOV     A,#0x6
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E4           CLR     A
   \   00002E   F0           MOVX    @DPTR,A
   2179              req.challenge = NULL;
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   2180          
   2181              // start EA processing
   2182              APSME_AuthenticateReq( &req );
   2183            }
   \                     ??CrossCallReturnLabel_169:
   \   00003A   12....       LCALL   ??APSME_AuthenticateReq?relay
   2184          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   00003D   7407         MOV     A,#0x7
   \   00003F   02....       LJMP    ??Subroutine88_0 & 0xFFFF
   2185          
   2186          /******************************************************************************
   2187           * @fn          ZDSecMgrAuthNwkKey
   2188           *
   2189           * @brief       Handle next step in authentication process
   2190           *
   2191           * @param       none
   2192           *
   2193           * @return      none
   2194           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2195          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2196          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2197            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   2198            {
   2199              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2200              {
   2201                uint8 parent[Z_EXTADDR_LEN];
   2202          
   2203                // get parent's EXT address
   2204                NLME_GetCoordExtAddr( parent );
   2205          
   2206                // begin entity authentication with parent
   2207                ZDSecMgrAuthInitiate( parent );
   2208              }
   2209              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2210              {
   2211                // inform ZDO that device has been authenticated
   2212                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   2213              }
   2214            }
   2215          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   80..         SJMP    ??Subroutine92_0
   2216          
   2217          /******************************************************************************
   2218           * PUBLIC FUNCTIONS
   2219           */
   2220          /******************************************************************************
   2221           * @fn          ZDSecMgrInit
   2222           *
   2223           * @brief       Initialize ZigBee Device Security Manager.
   2224           *
   2225           * @param       none
   2226           *
   2227           * @return      none
   2228           */
   2229          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2230          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2231          void ZDSecMgrAddrMgrCB( uint8           update,
   2232                                  AddrMgrEntry_t* newEntry,
   2233                                  AddrMgrEntry_t* oldEntry )
   2234          {
   2235            (void)update;
   2236            (void)newEntry;
   2237            (void)oldEntry;
   2238          }
   2239          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2240          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2241          void ZDSecMgrInit( void )
   \                     ZDSecMgrInit:
   \   000000                REQUIRE ?Subroutine5
   \   000000                ; // Fall through to label ?Subroutine5

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   2242          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2243            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2244                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2245            {
   2246              // initialize sub modules
   2247              ZDSecMgrMasterKeyInit();
   2248              ZDSecMgrEntryInit();
   2249          
   2250              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2251              {
   2252                ZDSecMgrCtrlInit();
   2253              }
   2254          
   2255              // register with Address Manager
   2256              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2257              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2258              #endif
   2259            }
   2260          
   2261            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2262            {
   2263              // configure SKA slot data
   2264              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2265            }
   2266            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2267            {
   2268              // Setup the preconfig Trust Center Link Key
   2269              TrustCenterLinkKey.key = zgPreConfigTCLinkKey;
   2270              TrustCenterLinkKey.txFrmCntr = 0;
   2271              TrustCenterLinkKey.rxFrmCntr = 0;
   2272          #if defined ( NV_RESTORE )
   2273              if ( osal_nv_item_init( ZCD_NV_SECURE_TCLINKKEY_TXFRAME, sizeof(uint32), &(TrustCenterLinkKey.txFrmCntr) ) == ZSUCCESS )
   2274              {
   2275                osal_nv_read( ZCD_NV_SECURE_TCLINKKEY_TXFRAME, 0, sizeof(uint32), &(TrustCenterLinkKey.txFrmCntr) );
   2276              }
   2277              if ( osal_nv_item_init( ZCD_NV_SECURE_TCLINKKEY_RXFRAME, sizeof(uint32), &(TrustCenterLinkKey.rxFrmCntr) ) == ZSUCCESS )
   2278              {
   2279                osal_nv_read( ZCD_NV_SECURE_TCLINKKEY_RXFRAME, 0, sizeof(uint32), &(TrustCenterLinkKey.rxFrmCntr) );
   2280              }
   2281          #endif
   2282              APSME_TCLinkKeySetup( 0x0000, &TrustCenterLinkKey );
   2283            }
   2284          
   2285            if ( ZG_SECURE_ENABLED )
   2286            {
   2287              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2288              {
   2289                // setup joining permissions
   2290                ZDSecMgrPermitJoiningEnabled = TRUE;
   2291                ZDSecMgrPermitJoiningTimed   = FALSE;
   2292              }
   2293            }
   2294          
   2295            // configure security based on security mode and type of device
   2296            ZDSecMgrConfig();
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay
   2297          }
   \   000007   80..         SJMP    ??Subroutine92_0
   2298          
   2299          /******************************************************************************
   2300           * @fn          ZDSecMgrConfig
   2301           *
   2302           * @brief       Configure ZigBee Device Security Manager.
   2303           *
   2304           * @param       none
   2305           *
   2306           * @return      none
   2307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2308          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   80..         SJMP    ?Subroutine5
   2309          {
   2310            if ( ZG_SECURE_ENABLED )
   2311            {
   2312              SSP_Init();
   2313          
   2314              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2315                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2316              {
   2317                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2318                {
   2319                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2320                  APSME_SecurityCM_CD();
   2321                }
   2322                else if ( ZSTACK_ROUTER_BUILD )
   2323                {
   2324                  // COMMERCIAL MODE - ROUTER DEVICE
   2325                  APSME_SecurityCM_RD();
   2326                }
   2327                else
   2328                {
   2329                  // COMMERCIAL MODE - END DEVICE
   2330                  APSME_SecurityCM_ED();
   2331                }
   2332              }
   2333              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2334              {
   2335                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2336                {
   2337                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2338                  APSME_SecurityRM_CD();
   2339                }
   2340                else if ( ZSTACK_ROUTER_BUILD )
   2341                {
   2342                  // RESIDENTIAL MODE - ROUTER DEVICE
   2343                  APSME_SecurityRM_RD();
   2344                }
   2345                else
   2346                {
   2347                  // RESIDENTIAL MODE - END DEVICE
   2348                  APSME_SecurityRM_ED();
   2349                }
   2350              }
   2351            }
   2352            else
   2353            {
   2354              // NO SECURITY
   2355              APSME_SecurityNM();
   2356            }
   2357          }
   2358          
   2359          /******************************************************************************
   2360           * @fn          ZDSecMgrPermitJoining
   2361           *
   2362           * @brief       Process request to change joining permissions.
   2363           *
   2364           * @param       duration - [in] timed duration for join in seconds
   2365           *                         - 0x00 not allowed
   2366           *                         - 0xFF allowed without timeout
   2367           *
   2368           * @return      uint8 - success(TRUE:FALSE)
   2369           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2370          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2371          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2372            uint8 accept;
   2373          
   2374          
   2375            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   2376          
   2377            if ( duration > 0 )
   \   00000B   E8           MOV     A,R0
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ      ??ZDSecMgrPermitJoining_0
   2378            {
   2379              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
   2380          
   2381              if ( duration != 0xFF )
   \   000014   74FF         MOV     A,#-0x1
   \   000016   68           XRL     A,R0
   \   000017   6009         JZ      ??ZDSecMgrPermitJoining_1
   2382              {
   2383                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??ZDSecMgrPermitJoining_2
   2384              }
   2385            }
   2386            else
   2387            {
   2388              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR     A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX    @DPTR,A
   2389            }
   2390          
   2391            accept = TRUE;
   2392          
   2393            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV     R1,#0x1
   \   000024   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2394          }
   2395          
   2396          /******************************************************************************
   2397           * @fn          ZDSecMgrPermitJoiningTimeout
   2398           *
   2399           * @brief       Process permit joining timeout
   2400           *
   2401           * @param       none
   2402           *
   2403           * @return      none
   2404           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2405          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2406          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2407            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2408            {
   2409              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   2410              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   2411            }
   2412          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2413          
   2414          /******************************************************************************
   2415           * @fn          ZDSecMgrNewDeviceEvent
   2416           *
   2417           * @brief       Process a the new device event, if found reset new device
   2418           *              event/timer.
   2419           *
   2420           * @param       none
   2421           *
   2422           * @return      uint8 - found(TRUE:FALSE)
   2423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2424          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2425          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2426            uint8                 found;
   2427            ZDSecMgrDevice_t      device;
   2428            AddrMgrEntry_t        addrEntry;
   2429            associated_devices_t* assoc;
   2430            ZStatus_t             status;
   2431          
   2432            // initialize return results
   2433            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   2434          
   2435            // look for device in the security init state
   2436            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   AE..         MOV     R6,?V0 + 2
   \   000018   AF..         MOV     R7,?V0 + 3
   2437          
   2438            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2439            {
   2440              // device found
   2441              found = TRUE;
   \   000021   75..01       MOV     ?V0 + 0,#0x1
   2442          
   2443              // check for preconfigured security
   2444              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV     DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7003         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2445              {
   2446                // set association status to authenticated
   2447                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2448              }
   2449          
   2450              // set up device info
   2451              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002F   740A         MOV     A,#0xa
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   2452              addrEntry.index = assoc->addrIdx;
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   00003D   7415         MOV     A,#0x15
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   2453              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_210:
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   AA82         MOV     R2,DPL
   \   00004A   AB83         MOV     R3,DPH
   \   00004C   12....       LCALL   ??AddrMgrEntryGet?relay
   2454          
   2455              device.nwkAddr    = assoc->shortAddr;
   \   00004F   8E82         MOV     DPL,R6
   \   000051   8F83         MOV     DPH,R7
   \   000053   12....       LCALL   ?Subroutine29 & 0xFFFF
   2456              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_192:
   \   000056   740D         MOV     A,#0xd
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   A882         MOV     R0,DPL
   \   00005D   A983         MOV     R1,DPH
   \   00005F   7402         MOV     A,#0x2
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   2457              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_186:
   \   000067                ; Setup parameters for call to function NLME_GetShortAddr
   \   000067   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00006A   7404         MOV     A,#0x4
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   12....       LCALL   ??Subroutine96_0 & 0xFFFF
   2458              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_201:
   \   000072   7406         MOV     A,#0x6
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   E4           CLR     A
   \   000078   F0           MOVX    @DPTR,A
   2459              device.devStatus  = assoc->devStatus;
   \   000079   EE           MOV     A,R6
   \   00007A   2405         ADD     A,#0x5
   \   00007C   FE           MOV     R6,A
   \   00007D   EF           MOV     A,R7
   \   00007E   3400         ADDC    A,#0x0
   \   000080   FF           MOV     R7,A
   \   000081   8E82         MOV     DPL,R6
   \   000083   8F83         MOV     DPH,R7
   \   000085   E0           MOVX    A,@DPTR
   \   000086   C0E0         PUSH    A
   \   000088   7407         MOV     A,#0x7
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   D0E0         POP     A
   \   00008F   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   2460          
   2461              // process new device
   2462              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_170:
   \   000092   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   000095   E9           MOV     A,R1
   \   000096   F8           MOV     R0,A
   2463          
   2464              if ( status == ZSuccess )
   \   000097   700A         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2465              {
   2466                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   000099   8E82         MOV     DPL,R6
   \   00009B   8F83         MOV     DPH,R7
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   C2E2         CLR     0xE0 /* A   */.2
   \   0000A0   F0           MOVX    @DPTR,A
   \   0000A1   8011         SJMP    ??ZDSecMgrNewDeviceEvent_0
   2467              }
   2468              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   0000A3   74C8         MOV     A,#-0x38
   \   0000A5   68           XRL     A,R0
   \   0000A6   700C         JNZ     ??ZDSecMgrNewDeviceEvent_0
   2469              {
   2470                AssocRemove( addrEntry.extAddr );
   \   0000A8                ; Setup parameters for call to function AssocRemove
   \   0000A8   740D         MOV     A,#0xd
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   AA82         MOV     R2,DPL
   \   0000AF   AB83         MOV     R3,DPH
   \   0000B1   12....       LCALL   ??AssocRemove?relay
   2471              }
   2472            }
   2473          
   2474            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000B4   A9..         MOV     R1,?V0 + 0
   \   0000B6   7417         MOV     A,#0x17
   \   0000B8   02....       LJMP    ??Subroutine104_0 & 0xFFFF
   2475          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000003                REQUIRE ??Subroutine94_0
   \   000003                ; // Fall through to label ??Subroutine94_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine94_0:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine95_0
   \   000006                ; // Fall through to label ??Subroutine95_0
   2476          
   2477          /******************************************************************************
   2478           * @fn          ZDSecMgrEvent
   2479           *
   2480           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2481           *
   2482           * @param       none
   2483           *
   2484           * @return      none
   2485           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2486          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2487          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2488            uint8            action;
   2489            uint8            restart;
   2490            uint16           index;
   2491            AddrMgrEntry_t   entry;
   2492            ZDSecMgrDevice_t device;
   2493          
   2494          
   2495            // verify data is available
   2496            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000010   7003         JNZ     $+5
   \   000012   02....       LJMP    ??ZDSecMgrEvent_0 & 0xFFFF
   2497            {
   2498              action  = FALSE;
   \   000015   75..00       MOV     ?V0 + 1,#0x0
   2499              restart = FALSE;
   \   000018   75..00       MOV     ?V0 + 0,#0x0
   2500          
   2501              // update all the counters
   2502              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001B   7E00         MOV     R6,#0x0
   \   00001D   7F00         MOV     R7,#0x0
   2503              {
   2504                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_1:
   \   00001F   EE           MOV     A,R6
   \   000020   F8           MOV     R0,A
   \   000021   EF           MOV     A,R7
   \   000022   F9           MOV     R1,A
   \   000023   E8           MOV     A,R0
   \   000024   75F007       MOV     B,#0x7
   \   000027   A4           MUL     AB
   \   000028   F8           MOV     R0,A
   \   000029   AAF0         MOV     R2,B
   \   00002B   75F007       MOV     B,#0x7
   \   00002E   E9           MOV     A,R1
   \   00002F   A4           MUL     AB
   \   000030   2A           ADD     A,R2
   \   000031   F9           MOV     R1,A
   \   000032   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000035   E0           MOVX    A,@DPTR
   \   000036   28           ADD     A,R0
   \   000037   FA           MOV     R2,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   39           ADDC    A,R1
   \   00003B   FB           MOV     R3,A
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   7003         JNZ     $+5
   \   000048   02....       LJMP    ??ZDSecMgrEvent_2 & 0xFFFF
   2505                {
   2506                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   00004B   EA           MOV     A,R2
   \   00004C   2406         ADD     A,#0x6
   \   00004E   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000051   6002         JZ      ??ZDSecMgrEvent_3
   2507                  {
   2508                    ZDSecMgrCtrlData[index].cntr--;
   \   000053   14           DEC     A
   \   000054   F0           MOVX    @DPTR,A
   2509                  }
   2510          
   2511                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_3:
   \   000055   E5..         MOV     A,?V0 + 1
   \   000057   A2E0         MOV     C,0xE0 /* A   */.0
   \   000059   5003         JNC     $+5
   \   00005B   02....       LJMP    ??ZDSecMgrEvent_4 & 0xFFFF
   \   00005E   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000061   E0           MOVX    A,@DPTR
   \   000062   28           ADD     A,R0
   \   000063   F8           MOV     R0,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   39           ADDC    A,R1
   \   000067   F9           MOV     R1,A
   \   000068   8882         MOV     DPL,R0
   \   00006A   8983         MOV     DPH,R1
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   706D         JNZ     ??ZDSecMgrEvent_4
   2512                  {
   2513                    action = TRUE;
   \   000075   75..01       MOV     ?V0 + 1,#0x1
   2514          
   2515                    // update from control data
   2516                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   000078   8882         MOV     DPL,R0
   \   00007A   8983         MOV     DPH,R1
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   12....       LCALL   ??Subroutine86_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ??Subroutine96_0 & 0xFFFF
   2517                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_202:
   \   000089   8882         MOV     DPL,R0
   \   00008B   8983         MOV     DPH,R1
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   C0E0         PUSH    A
   \   000094   7406         MOV     A,#0x6
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   D0E0         POP     A
   \   00009B   F0           MOVX    @DPTR,A
   2518                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   00009C   7408         MOV     A,#0x8
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   2519          
   2520                    // set the user and address index
   2521                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_211:
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   7402         MOV     A,#0x2
   \   0000A9   F0           MOVX    @DPTR,A
   2522                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \   0000AA   8882         MOV     DPL,R0
   \   0000AC   8983         MOV     DPH,R1
   \   0000AE   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   0000B1   F9           MOV     R1,A
   \   0000B2   7415         MOV     A,#0x15
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   2523          
   2524                    // get the address data
   2525                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_212:
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   AA82         MOV     R2,DPL
   \   0000BF   AB83         MOV     R3,DPH
   \   0000C1   12....       LCALL   ??AddrMgrEntryGet?relay
   2526          
   2527                    // set device address data
   2528                    device.nwkAddr = entry.nwkAddr;
   \   0000C4   740B         MOV     A,#0xb
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   12....       LCALL   ?Subroutine29 & 0xFFFF
   2529                    device.extAddr = entry.extAddr;
   \                     ??CrossCallReturnLabel_193:
   \   0000CC   740D         MOV     A,#0xd
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   A882         MOV     R0,DPL
   \   0000D3   A983         MOV     R1,DPH
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   12....       LCALL   ?Subroutine12 & 0xFFFF
   2530          
   2531                    // update from entry data
   2532                    ZDSecMgrDeviceCtrlHandler( &device );
   2533                  }
   \                     ??CrossCallReturnLabel_0:
   \   0000DD   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   \   0000E0   8003         SJMP    ??ZDSecMgrEvent_2
   2534                  else
   2535                  {
   2536                    restart = TRUE;
   \                     ??ZDSecMgrEvent_4:
   \   0000E2   75..01       MOV     ?V0 + 0,#0x1
   2537                  }
   2538                }
   2539              }
   \                     ??ZDSecMgrEvent_2:
   \   0000E5   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0000E8   5003         JNC     $+5
   \   0000EA   02....       LJMP    ??ZDSecMgrEvent_1 & 0xFFFF
   2540          
   2541              // check for timer restart
   2542              if ( restart == TRUE )
   \   0000ED   E5..         MOV     A,?V0 + 0
   \   0000EF   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000F1   5010         JNC     ??ZDSecMgrEvent_0
   2543              {
   2544                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000F3                ; Setup parameters for call to function osal_start_timerEx
   \   0000F3   7C64         MOV     R4,#0x64
   \   0000F5   7D00         MOV     R5,#0x0
   \   0000F7   7A00         MOV     R2,#0x0
   \   0000F9   7B01         MOV     R3,#0x1
   \   0000FB   90....       MOV     DPTR,#ZDAppTaskID
   \   0000FE   E0           MOVX    A,@DPTR
   \   0000FF   F9           MOV     R1,A
   \   000100   12....       LCALL   ??osal_start_timerEx?relay
   2545              }
   2546            }
   2547          }
   \                     ??ZDSecMgrEvent_0:
   \   000103   7417         MOV     A,#0x17
   \   000105   80..         SJMP    ??Subroutine99_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   EF           MOV     A,R7
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET
   2548          
   2549          /******************************************************************************
   2550           * @fn          ZDSecMgrEstablishKeyCfm
   2551           *
   2552           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2553           *
   2554           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2555           *
   2556           * @return      none
   2557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2558          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2559          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2560            // send the NWK key
   2561            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2562            {
   2563              // update control for specified EXT address
   2564              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2565            }
   2566            else
   2567            {
   2568              // this should be done when receiving the NWK key
   2569              // if devState ==
   2570              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2571                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2572          
   2573              // if not in joining state -- this should trigger an event for an
   2574              // end point that requested SKKE
   2575              // if ( devState == DEV_END_DEVICE )
   2576             //       devState == DEV_ROUTER;
   2577          
   2578            }
   2579          }
   \   000000   02....       LJMP    ?BRET
   2580          
   2581          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2582          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2583          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2584            uint8  match;
   2585            uint8  lookup[Z_EXTADDR_LEN];
   2586          
   2587            match = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2588          
   2589            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000022   E9           MOV     A,R1
   \   000023   6014         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2590            {
   2591              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2592            }
   2593          
   2594            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7408         MOV     A,#0x8
   \   00003D   02....       LJMP    ??Subroutine88_0 & 0xFFFF
   2595          }
   2596          
   2597          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2598          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2599          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2600            uint16 ami;
   2601            uint8* key;
   2602          
   2603            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7043         JNZ     ??ZDSecMgrTCDataLoad_0
   2604            {
   2605              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   8582..       MOV     ?V0 + 0,DPL
   \   000019   8583..       MOV     ?V0 + 1,DPH
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   EA           MOV     A,R2
   \   000022   FC           MOV     R4,A
   \   000023   EB           MOV     A,R3
   \   000024   FD           MOV     R5,A
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000031   E9           MOV     A,R1
   \   000032   7019         JNZ     ??CrossCallReturnLabel_56
   2606              {
   2607                // if preconfigured load key
   2608                if ( zgPreConfigKeys == TRUE )
   \   000034   90....       MOV     DPTR,#zgPreConfigKeys
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6401         XRL     A,#0x1
   \   00003A   7011         JNZ     ??CrossCallReturnLabel_56
   2609                {
   2610                  if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000044   6007         JZ      ??CrossCallReturnLabel_56
   2611                  {
   2612                    ZDSecMgrMasterKeyStore( ami, ZDSecMgrTCMasterKey );
   \   000046                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000046   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   000048   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00004A   12....       LCALL   ?Subroutine47 & 0xFFFF
   2613                  }
   2614                }
   2615              }
   2616          
   2617              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??CrossCallReturnLabel_56:
   \   00004D   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000050   7401         MOV     A,#0x1
   \   000052   F0           MOVX    @DPTR,A
   2618            }
   2619          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000053   7404         MOV     A,#0x4
   \   000055   02....       LJMP    ??Subroutine99_0 & 0xFFFF
   2620          
   2621          /******************************************************************************
   2622           * @fn          ZDSecMgrEstablishKeyInd
   2623           *
   2624           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2625           *
   2626           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2627           *
   2628           * @return      none
   2629           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2630          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2631          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2632            ZDSecMgrDevice_t        device;
   2633            APSME_EstablishKeyRsp_t rsp;
   2634          
   2635          
   2636            // load Trust Center data if needed
   2637            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000011                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000011   AA..         MOV     R2,?V0 + 0
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2638          
   2639            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   000017   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   00001A                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   00001A   AA..         MOV     R2,?V0 + 0
   \   00001C   AB..         MOV     R3,?V0 + 1
   \   00001E   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay
   \   000021   E9           MOV     A,R1
   \   000022   6016         JZ      ??ZDSecMgrEstablishKeyInd_0
   2640            {
   2641              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2642              //OR
   2643              //!ZDSecMgrTCAuthenticated
   2644              //devtag.0604.critical
   2645                  //how is the parentAddr used here
   2646          
   2647              // initial SKKE from Trust Center via parent
   2648              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000024   7407         MOV     A,#0x7
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   E4           CLR     A
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   12....       LCALL   ?Subroutine21 & 0xFFFF
   2649              device.parentAddr = ind->srcAddr;
   2650            }
   \                     ??CrossCallReturnLabel_9:
   \   00002F   740B         MOV     A,#0xb
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E8           MOV     A,R0
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   E9           MOV     A,R1
   \   000038   801B         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2651            else
   2652            {
   2653              // Trust Center direct or E2E SKKE
   2654              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   00003A   85..82       MOV     DPL,?V0 + 2
   \   00003D   85..83       MOV     DPH,?V0 + 3
   \   000040   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000043   7407         MOV     A,#0x7
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   2655              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_187:
   \   00004B   740B         MOV     A,#0xb
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   74FE         MOV     A,#-0x2
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   04           INC     A
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000055   F0           MOVX    @DPTR,A
   2656            }
   2657          
   2658            device.extAddr = ind->initExtAddr;
   \   000056   7409         MOV     A,#0x9
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E5..         MOV     A,?V0 + 0
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E5..         MOV     A,?V0 + 1
   \   000061   F0           MOVX    @DPTR,A
   2659            //devtag.pro.security.0724.todo - verify usage
   2660            device.secure  = ind->nwkSecure;
   \   000062   EE           MOV     A,R6
   \   000063   240E         ADD     A,#0xe
   \   000065   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000068   C0E0         PUSH    A
   \   00006A   740D         MOV     A,#0xd
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   D0E0         POP     A
   \   000071   F0           MOVX    @DPTR,A
   2661          
   2662            // validate device for SKKE
   2663            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000072                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000072   7407         MOV     A,#0x7
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   AA82         MOV     R2,DPL
   \   000079   AB83         MOV     R3,DPH
   \   00007B   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay
   \   00007E   E9           MOV     A,R1
   \   00007F   7009         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2664            {
   2665              rsp.accept = TRUE;
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   7401         MOV     A,#0x1
   \   000088   8006         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2666            }
   2667            else
   2668            {
   2669              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   00008A   7404         MOV     A,#0x4
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   E4           CLR     A
   2670            }
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   000090   12....       LCALL   ?Subroutine21 & 0xFFFF
   2671          
   2672            rsp.dstAddr     = ind->srcAddr;
   \                     ??CrossCallReturnLabel_10:
   \   000093   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   2673            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_191:
   \   000096   EE           MOV     A,R6
   \   000097   2404         ADD     A,#0x4
   \   000099   F8           MOV     R0,A
   \   00009A   EF           MOV     A,R7
   \   00009B   3400         ADDC    A,#0x0
   \   00009D   F9           MOV     R1,A
   \   00009E   7402         MOV     A,#0x2
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   2674            //devtag.0604.todo - remove obsolete
   2675            rsp.apsSecure   = ind->apsSecure;
   \                     ??CrossCallReturnLabel_188:
   \   0000A6   EE           MOV     A,R6
   \   0000A7   240D         ADD     A,#0xd
   \   0000A9   F582         MOV     DPL,A
   \   0000AB   EF           MOV     A,R7
   \   0000AC   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   0000AF   C0E0         PUSH    A
   \   0000B1   7405         MOV     A,#0x5
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   D0E0         POP     A
   \   0000B8   F0           MOVX    @DPTR,A
   2676            rsp.nwkSecure   = ind->nwkSecure;
   \   0000B9   85..82       MOV     DPL,?V0 + 0
   \   0000BC   85..83       MOV     DPH,?V0 + 1
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   C0E0         PUSH    A
   \   0000C2   7406         MOV     A,#0x6
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   D0E0         POP     A
   \   0000C9   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   2677          
   2678            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_171:
   \   0000CC   12....       LCALL   ??APSME_EstablishKeyRsp?relay
   2679          }
   \   0000CF   7411         MOV     A,#0x11
   \   0000D1   80..         SJMP    ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 2
   \   000004   85..83       MOV     DPH,?V0 + 3
   \   000007   12....       LCALL   ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   F5..         MOV     ?V0 + 0,A
   \   000002   EF           MOV     A,R7
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000007   85..82       MOV     DPL,?V0 + 0
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   F5..         MOV     ?V0 + 2,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 3,A
   \   00000A   22           RET
   2680          //devtag.pro.security
   2681          #if 0
   2682          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2683          {
   2684            ZDSecMgrDevice_t        device;
   2685            APSME_EstablishKeyRsp_t rsp;
   2686          
   2687          
   2688            device.extAddr = ind->initExtAddr;
   2689            device.secure  = ind->secure;
   2690          
   2691            if ( ind->secure == FALSE )
   2692            {
   2693              // SKKE from Trust Center is not secured between child and parent
   2694              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2695              device.parentAddr = ind->srcAddr;
   2696            }
   2697            else
   2698            {
   2699              // SKKE from initiator should be secured
   2700              device.nwkAddr    = ind->srcAddr;
   2701              device.parentAddr = INVALID_NODE_ADDR;
   2702            }
   2703          
   2704            rsp.dstAddr     = ind->srcAddr;
   2705            rsp.initExtAddr = &ind->initExtAddr[0];
   2706            rsp.secure      = ind->secure;
   2707          
   2708            // validate device for SKKE
   2709            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2710            {
   2711              rsp.accept = TRUE;
   2712            }
   2713            else
   2714            {
   2715              rsp.accept = FALSE;
   2716            }
   2717          
   2718            APSME_EstablishKeyRsp( &rsp );
   2719          }
   2720          #endif
   2721          
   2722          /******************************************************************************
   2723           * @fn          ZDSecMgrTransportKeyInd
   2724           *
   2725           * @brief       Process the ZDO_TransportKeyInd_t message.
   2726           *
   2727           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2728           *
   2729           * @return      none
   2730           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2731          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2732          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2733            uint8 index;
   2734          
   2735            // load Trust Center data if needed
   2736            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000009                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000009   EE           MOV     A,R6
   \   00000A   2416         ADD     A,#0x16
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   3400         ADDC    A,#0x0
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2737          
   2738            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000014   EE           MOV     A,R6
   \   000015   2404         ADD     A,#0x4
   \   000017   F582         MOV     DPL,A
   \   000019   EF           MOV     A,R7
   \   00001A   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   00001D   606A         JZ      ??ZDSecMgrTransportKeyInd_0
   2739            {
   2740              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2741              //ZDSecMgrTCMasterKey( ind );
   2742              {
   2743                if ( zgPreConfigKeys != TRUE )
   2744                {
   2745                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2746                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2747                }
   2748                else
   2749                {
   2750                  // error condition - reject key
   2751                }
   2752              }
   2753            }
   2754            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2755                      ( ind->keyType == 6                 ) ||
   2756                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   00001F   6401         XRL     A,#0x1
   \   000021   600A         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6406         XRL     A,#0x6
   \   000026   6005         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000028   E0           MOVX    A,@DPTR
   \   000029   6405         XRL     A,#0x5
   \   00002B   705C         JNZ     ??ZDSecMgrTransportKeyInd_0
   2757            {
   2758              // check for dummy NWK key (all zeros)
   2759              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   00002D   7800         MOV     R0,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   00002F   88..         MOV     ?V0 + 0,R0
   \   000031   EE           MOV     A,R6
   \   000032   25..         ADD     A,?V0 + 0
   \   000034   F582         MOV     DPL,A
   \   000036   EF           MOV     A,R7
   \   000037   3400         ADDC    A,#0x0
   \   000039   F583         MOV     DPH,A
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   7007         JNZ     ??ZDSecMgrTransportKeyInd_3
   2760                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2761                    index++ );
   \   000044   08           INC     R0
   \   000045   E8           MOV     A,R0
   \   000046   C3           CLR     C
   \   000047   9410         SUBB    A,#0x10
   \   000049   40E4         JC      ??ZDSecMgrTransportKeyInd_2
   2762          
   2763              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00004B   7410         MOV     A,#0x10
   \   00004D   68           XRL     A,R0
   \   00004E   7013         JNZ     ??ZDSecMgrTransportKeyInd_4
   2764              {
   2765                // load preconfigured key - once!!
   2766                if ( !_NIB.nwkKeyLoaded )
   \   000050   90....       MOV     DPTR,#_NIB + 61
   \   000053   E0           MOVX    A,@DPTR
   \   000054   7030         JNZ     ??ZDSecMgrTransportKeyInd_5
   2767                {
   2768                  SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
   \   000056                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000056   7900         MOV     R1,#0x0
   \   000058   7A..         MOV     R2,#zgPreConfigKey & 0xff
   \   00005A   7B..         MOV     R3,#(zgPreConfigKey >> 8) & 0xff
   \   00005C   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2769                  SSP_SwitchNwkKey( 0 );
   \   00005F                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00005F   7900         MOV     R1,#0x0
   \   000061   8020         SJMP    ??ZDSecMgrTransportKeyInd_6
   2770                }
   2771              }
   2772              else
   2773              {
   2774                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000063   EE           MOV     A,R6
   \   000064   2405         ADD     A,#0x5
   \   000066   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000069   F9           MOV     R1,A
   \   00006A   EE           MOV     A,R6
   \   00006B   2406         ADD     A,#0x6
   \   00006D   FA           MOV     R2,A
   \   00006E   EF           MOV     A,R7
   \   00006F   3400         ADDC    A,#0x0
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2775                if ( !_NIB.nwkKeyLoaded )
   \   000075   90....       MOV     DPTR,#_NIB + 61
   \   000078   E0           MOVX    A,@DPTR
   \   000079   700B         JNZ     ??ZDSecMgrTransportKeyInd_5
   2776                {
   2777                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   00007B                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00007B   85..82       MOV     DPL,?V0 + 0
   \   00007E   85..83       MOV     DPH,?V0 + 1
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F9           MOV     R1,A
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   000083   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2778                }
   2779              }
   2780          
   2781              // handle next step in authentication process
   2782              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   000086                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   000086   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   2783            }
   2784            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2785            {
   2786              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2787              {
   2788                //ZDSecMgrTCLinkKey( ind );
   2789              }
   2790            }
   2791            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2792            {
   2793              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2794              {
   2795                uint16           ami;
   2796                AddrMgrEntry_t   entry;
   2797                ZDSecMgrEntry_t* entryZD;
   2798          
   2799                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2800          
   2801                if ( ind->initiator == TRUE )
   2802                {
   2803                  // get the ami data
   2804                  entry.user  = ADDRMGR_USER_SECURITY;
   2805                  entry.index = ami;
   2806                  AddrMgrEntryGet( &entry );
   2807          
   2808                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2809                  {
   2810                    APSME_EstablishKeyReq_t req;
   2811                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2812          
   2813                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2814          
   2815                    if ( entryZD == NULL )
   2816                    {
   2817                      // get new entry
   2818                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2819                      {
   2820                        // finish setting up entry
   2821                        entryZD->ami = ami;
   2822                      }
   2823                    }
   2824          
   2825                    req.respExtAddr = ind->srcExtAddr;
   2826                    req.method      = APSME_SKKE_METHOD;
   2827                    req.dstAddr     = entry.nwkAddr;
   2828                    //devtag.0604.todo - remove obsolete
   2829                    req.apsSecure   = FALSE;
   2830                    req.nwkSecure   = TRUE;
   2831                    APSME_EstablishKeyReq( &req );
   2832                  }
   2833                }
   2834                else
   2835                {
   2836                  if ( ami == INVALID_NODE_ADDR )
   2837                  {
   2838                    // store new EXT address
   2839                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2840                  }
   2841          
   2842                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2843                }
   2844          
   2845                //if ( entry.nwkAddr == INVALID_NODE_ADDR )
   2846                //{
   2847                //  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2848                //}
   2849              }
   2850            }
   2851            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2852            {
   2853              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2854              {
   2855                uint16           ami;
   2856                ZDSecMgrEntry_t* entry;
   2857          
   2858                // get the address index
   2859                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2860                {
   2861                  // store new EXT address
   2862                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2863                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2864                }
   2865          
   2866                ZDSecMgrEntryLookupAMI( ami, &entry );
   2867          
   2868                if ( entry == NULL )
   2869                {
   2870                  // get new entry
   2871                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2872                  {
   2873                    // finish setting up entry
   2874                    entry->ami = ami;
   2875                  }
   2876                }
   2877          
   2878                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2879              }
   2880            }
   2881          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000089   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   2882          
   2883          /******************************************************************************
   2884           * @fn          ZDSecMgrUpdateDeviceInd
   2885           *
   2886           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2887           *
   2888           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2889           *
   2890           * @return      none
   2891           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   740A         MOV     A,#0xa
   \   000002                REQUIRE ??Subroutine79_0
   \   000002                ; // Fall through to label ??Subroutine79_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2892          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2893          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2894            ZDSecMgrDevice_t device;
   2895          
   2896          
   2897            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   EB           MOV     A,R3
   \   00000F   3400         ADDC    A,#0x0
   \   000011   F583         MOV     DPH,A
   \   000013   12....       LCALL   ?Subroutine29 & 0xFFFF
   2898            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_194:
   \   000016   EA           MOV     A,R2
   \   000017   2404         ADD     A,#0x4
   \   000019   F8           MOV     R0,A
   \   00001A   EB           MOV     A,R3
   \   00001B   3400         ADDC    A,#0x0
   \   00001D   F9           MOV     R1,A
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ?Subroutine18 & 0xFFFF
   2899            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_6:
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine12 & 0xFFFF
   2900          
   2901            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2902            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2903            //{
   2904            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2905            //  {
   2906            //    device.secure = TRUE;
   2907            //  }
   2908            //  else
   2909            //  {
   2910            //    device.secure = FALSE;
   2911            //  }
   2912          
   2913              // try to join this device
   2914              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_1:
   \   00002C   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   2915            //}
   2916          }
   \   00002F   02....       LJMP    ?Subroutine6 & 0xFFFF
   2917          
   2918          /******************************************************************************
   2919           * @fn          ZDSecMgrRemoveDeviceInd
   2920           *
   2921           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2922           *
   2923           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2924           *
   2925           * @return      none
   2926           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2927          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2928          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2929            ZDSecMgrDevice_t device;
   2930          
   2931          
   2932            // only accept from Trust Center
   2933            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000013   7038         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2934            {
   2935              // look up NWK address
   2936              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000015   EA           MOV     A,R2
   \   000016   2404         ADD     A,#0x4
   \   000018   FE           MOV     R6,A
   \   000019   EB           MOV     A,R3
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   FF           MOV     R7,A
   \   00001D                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   AC82         MOV     R4,DPL
   \   000025   AD83         MOV     R5,DPH
   \   000027   EE           MOV     A,R6
   \   000028   FA           MOV     R2,A
   \   000029   EF           MOV     A,R7
   \   00002A   FB           MOV     R3,A
   \   00002B   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00002E   E9           MOV     A,R1
   \   00002F   6401         XRL     A,#0x1
   \   000031   701A         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2937              {
   2938                device.parentAddr = NLME_GetShortAddr();
   \   000033                ; Setup parameters for call to function NLME_GetShortAddr
   \   000033   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000036   7404         MOV     A,#0x4
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ??Subroutine96_0 & 0xFFFF
   2939                device.extAddr    = ind->childExtAddr;
   \                     ??CrossCallReturnLabel_203:
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   EE           MOV     A,R6
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   EF           MOV     A,R7
   \   000047   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   2940          
   2941                // remove device
   2942                ZDSecMgrDeviceRemove( &device );
   2943              }
   2944            }
   \                     ??CrossCallReturnLabel_172:
   \   00004A   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2945          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   00004D   740A         MOV     A,#0xa
   \   00004F   02....       LJMP    ??Subroutine88_0 & 0xFFFF
   2946          
   2947          /******************************************************************************
   2948           * @fn          ZDSecMgrRequestKeyInd
   2949           *
   2950           * @brief       Process the ZDO_RequestKeyInd_t message.
   2951           *
   2952           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2953           *
   2954           * @return      none
   2955           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2956          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2957          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2958            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   7401         MOV     A,#0x1
   \   000010   68           XRL     A,R0
   \   000011   6008         JZ      ??ZDSecMgrRequestKeyInd_0
   2959            {
   2960            }
   2961            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   7402         MOV     A,#0x2
   \   000015   68           XRL     A,R0
   \   000016   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   2962            {
   2963              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   2964            }
   2965            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2966            {
   2967            }
   2968            //else ignore
   2969          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2970          
   2971          /******************************************************************************
   2972           * @fn          ZDSecMgrSwitchKeyInd
   2973           *
   2974           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2975           *
   2976           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2977           *
   2978           * @return      none
   2979           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2980          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2981          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2982            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2983          
   2984            // Save if nv
   2985            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   ??ZDApp_NVUpdate?relay
   2986          }
   \   000014   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2987          
   2988          /******************************************************************************
   2989           * @fn          ZDSecMgrAuthenticateInd
   2990           *
   2991           * @brief       Process the ZDO_AuthenticateInd_t message.
   2992           *
   2993           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2994           *
   2995           * @return      none
   2996           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2997          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   2998          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2999            APSME_AuthenticateReq_t req;
   3000            AddrMgrEntry_t          entry;
   3001          
   3002          
   3003            // update the address manager
   3004            //---------------------------------------------------------------------------
   3005            // note:
   3006            // required for EA processing, but ultimately EA logic could also use the
   3007            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3008            // table is supposed to have authentication states for neighbors
   3009            //---------------------------------------------------------------------------
   3010            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3011            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000019   85..82       MOV     DPL,?V0 + 2
   \   00001C   F583         MOV     DPH,A
   \   00001E   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000021   7408         MOV     A,#0x8
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   3012            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_189:
   \   000029   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00002C                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00002C   AC..         MOV     R4,?V0 + 0
   \   00002E   FD           MOV     R5,A
   \   00002F   740A         MOV     A,#0xa
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   AA82         MOV     R2,DPL
   \   000036   AB83         MOV     R3,DPH
   \   000038   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3013          
   3014            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00003B                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00003B   7407         MOV     A,#0x7
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   AA82         MOV     R2,DPL
   \   000042   AB83         MOV     R3,DPH
   \   000044   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000047   E9           MOV     A,R1
   \   000048   6401         XRL     A,#0x1
   \   00004A   7031         JNZ     ??ZDSecMgrAuthenticateInd_0
   3015            {
   3016              // set request fields
   3017              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00004C   85..82       MOV     DPL,?V0 + 2
   \   00004F   85..83       MOV     DPH,?V0 + 3
   \   000052   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000055   12....       LCALL   ?Subroutine28 & 0xFFFF
   3018              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_141:
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E5..         MOV     A,?V0 + 0
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E5..         MOV     A,?V0 + 1
   \   000061   F0           MOVX    @DPTR,A
   3019              req.action    = APSME_EA_ACCEPT;
   \   000062   7406         MOV     A,#0x6
   \   000064   12....       LCALL   ?XSTACK_DISP0_8
   \   000067   7401         MOV     A,#0x1
   \   000069   F0           MOVX    @DPTR,A
   3020              req.challenge = ind->aps.challenge;
   \   00006A   EE           MOV     A,R6
   \   00006B   240C         ADD     A,#0xc
   \   00006D   F8           MOV     R0,A
   \   00006E   EF           MOV     A,R7
   \   00006F   3400         ADDC    A,#0x0
   \   000071   F9           MOV     R1,A
   \   000072   7404         MOV     A,#0x4
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?Subroutine12 & 0xFFFF
   3021          
   3022              // start EA processing
   3023              APSME_AuthenticateReq( &req );
   3024            }
   \                     ??CrossCallReturnLabel_2:
   \   00007A   12....       LCALL   ??APSME_AuthenticateReq?relay
   3025          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   00007D   7414         MOV     A,#0x14
   \   00007F   02....       LJMP    ??Subroutine104_0 & 0xFFFF
   3026          
   3027          /******************************************************************************
   3028           * @fn          ZDSecMgrAuthenticateCfm
   3029           *
   3030           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3031           *
   3032           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3033           *
   3034           * @return      none
   3035           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3036          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3037          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3038            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV     A,R2
   \   000005   240B         ADD     A,#0xb
   \   000007   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   00000A   701F         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3039            {
   3040              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   6401         XRL     A,#0x1
   \   000015   7014         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   000017   90....       MOV     DPTR,#devState
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   6405         XRL     A,#0x5
   \   00001D   700C         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3041              {
   3042                // inform ZDO that device has been authenticated
   3043                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00001F                ; Setup parameters for call to function osal_set_event
   \   00001F   7A80         MOV     R2,#-0x80
   \   000021   7B00         MOV     R3,#0x0
   \   000023   90....       MOV     DPTR,#ZDAppTaskID
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F9           MOV     R1,A
   \   000028   12....       LCALL   ??osal_set_event?relay
   3044              }
   3045            }
   3046          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002B   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   3047          
   3048          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3049          /******************************************************************************
   3050           * @fn          ZDSecMgrUpdateNwkKey
   3051           *
   3052           * @brief       Load a new NWK key and trigger a network wide update.
   3053           *
   3054           * @param       key       - [in] new NWK key
   3055           * @param       keySeqNum - [in] new NWK key sequence number
   3056           *
   3057           * @return      ZStatus_t
   3058           */
   3059          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3060          {
   3061            ZStatus_t               status;
   3062            APSME_TransportKeyReq_t req;
   3063          
   3064            // initialize common elements of local variables
   3065            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3066              req.keyType   = KEY_TYPE_NWK_HIGH;
   3067            else
   3068              req.keyType   = KEY_TYPE_NWK;
   3069          
   3070            req.dstAddr   = dstAddr;
   3071            req.keySeqNum = keySeqNum;
   3072            req.key       = key;
   3073            req.extAddr   = NULL;
   3074            req.nwkSecure = TRUE;
   3075            req.apsSecure = TRUE;
   3076            req.tunnel    = NULL;
   3077          
   3078            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3079            {
   3080              ZDSecMgrEntry_t*        entry;
   3081              uint16                  index;
   3082              AddrMgrEntry_t          addrEntry;
   3083          
   3084              addrEntry.user = ADDRMGR_USER_SECURITY;
   3085          
   3086              status = ZFailure;
   3087          
   3088              // verify data is available
   3089              if ( ZDSecMgrEntries != NULL )
   3090              {
   3091                // find available entry
   3092                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3093                {
   3094                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3095                  {
   3096                    // return successful result
   3097                    entry = &ZDSecMgrEntries[index];
   3098          
   3099                    // get NWK address
   3100                    addrEntry.index = entry->ami;
   3101                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3102                    {
   3103                      req.dstAddr = addrEntry.nwkAddr;
   3104                      req.extAddr = addrEntry.extAddr;
   3105                      status = APSME_TransportKeyReq( &req );
   3106                    }
   3107                  }
   3108                }
   3109              }
   3110            }
   3111            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3112            {
   3113              status = APSME_TransportKeyReq( &req );
   3114            }
   3115          
   3116            SSP_UpdateNwkKey( key, keySeqNum );
   3117          
   3118            // Save if nv
   3119            ZDApp_NVUpdate();
   3120          
   3121            return status;
   3122          }
   3123          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3124          
   3125          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3126          /******************************************************************************
   3127           * @fn          ZDSecMgrSwitchNwkKey
   3128           *
   3129           * @brief       Causes the NWK key to switch via a network wide command.
   3130           *
   3131           * @param       keySeqNum - [in] new NWK key sequence number
   3132           *
   3133           * @return      ZStatus_t
   3134           */
   3135          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3136          {
   3137            ZStatus_t            status;
   3138            APSME_SwitchKeyReq_t req;
   3139          
   3140            // initialize common elements of local variables
   3141            req.dstAddr = dstAddr;
   3142            req.keySeqNum = keySeqNum;
   3143          
   3144            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3145            {
   3146              ZDSecMgrEntry_t*     entry;
   3147              uint16               index;
   3148              AddrMgrEntry_t       addrEntry;
   3149          
   3150              addrEntry.user = ADDRMGR_USER_SECURITY;
   3151          
   3152              status = ZFailure;
   3153          
   3154              // verify data is available
   3155              if ( ZDSecMgrEntries != NULL )
   3156              {
   3157                // find available entry
   3158                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3159                {
   3160                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3161                  {
   3162                    // return successful result
   3163                    entry = &ZDSecMgrEntries[index];
   3164          
   3165                    // get NWK address
   3166                    addrEntry.index = entry->ami;
   3167          
   3168                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3169                    {
   3170                      req.dstAddr = addrEntry.nwkAddr;
   3171                      status = APSME_SwitchKeyReq( &req );
   3172                    }
   3173                  }
   3174                }
   3175              }
   3176            }
   3177            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3178            {
   3179              status = APSME_SwitchKeyReq( &req );
   3180            }
   3181          
   3182            SSP_SwitchNwkKey( keySeqNum );
   3183          
   3184            // Save if nv
   3185            ZDApp_NVUpdate();
   3186          
   3187            return status;
   3188          }
   3189          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3190          
   3191          #if ( ZG_BUILD_JOINING_TYPE )
   3192          /******************************************************************************
   3193           * @fn          ZDSecMgrRequestAppKey
   3194           *
   3195           * @brief       Request an application key with partner.
   3196           *
   3197           * @param       partNwkAddr - [in] partner network address
   3198           *
   3199           * @return      ZStatus_t
   3200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3201          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3202          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 12
   \   000004   74F4         MOV     A,#-0xc
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   3203            ZStatus_t             status;
   3204            APSME_RequestKeyReq_t req;
   3205            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3206          
   3207          
   3208            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   000009                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000009   7404         MOV     A,#0x4
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   AC82         MOV     R4,DPL
   \   000010   AD83         MOV     R5,DPH
   \   000012   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000015   E9           MOV     A,R1
   \   000016   6025         JZ      ??ZDSecMgrRequestAppKey_0
   3209            {
   3210              req.dstAddr = 0;
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   E4           CLR     A
   \   00001F   F0           MOVX    @DPTR,A
   3211              req.keyType = KEY_TYPE_APP_MASTER;
   \   000020   04           INC     A
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
   3212              req.partExtAddr = partExtAddr;
   \   000027   7404         MOV     A,#0x4
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   A882         MOV     R0,DPL
   \   00002E   A983         MOV     R1,DPH
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine12 & 0xFFFF
   3213              status = APSME_RequestKeyReq( &req );
   3214            }
   \                     ??CrossCallReturnLabel_3:
   \   000038   12....       LCALL   ??APSME_RequestKeyReq?relay
   \   00003B   8002         SJMP    ??ZDSecMgrRequestAppKey_1
   3215            else
   3216            {
   3217              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   00003D   7901         MOV     R1,#0x1
   3218            }
   3219          
   3220            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   00003F   740C         MOV     A,#0xc
   \   000041   02....       LJMP    ??Subroutine79_0 & 0xFFFF
   3221          }
   3222          #endif // ( ZG_BUILD_JOINING_TYPE )
   3223          
   3224          #if ( ZG_BUILD_JOINING_TYPE )
   3225          /******************************************************************************
   3226           * @fn          ZDSecMgrSetupPartner
   3227           *
   3228           * @brief       Setup for application key partner.
   3229           *
   3230           * @param       partNwkAddr - [in] partner network address
   3231           *
   3232           * @return      ZStatus_t
   3233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3234          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3235          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   3236            AddrMgrEntry_t entry;
   3237            ZStatus_t      status;
   3238          
   3239            status = ZFailure;
   \   000012   75..01       MOV     ?V0 + 2,#0x1
   3240          
   3241            // update the address manager
   3242            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7402         MOV     A,#0x2
   \   00001D   F0           MOVX    @DPTR,A
   3243            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC     A
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   3244            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \   000027                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000027   7403         MOV     A,#0x3
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ?Subroutine54 & 0xFFFF
   3245          
   3246            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_73:
   \   00002F   7036         JNZ     ??ZDSecMgrSetupPartner_0
   3247            {
   3248              status = ZSuccess;
   \   000031   75..00       MOV     ?V0 + 2,#0x0
   3249          
   3250              // check for address discovery
   3251              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000034   74FE         MOV     A,#-0x2
   \   000036   6E           XRL     A,R6
   \   000037   7003         JNZ     ??ZDSecMgrSetupPartner_1
   \   000039   74FF         MOV     A,#-0x1
   \   00003B   6F           XRL     A,R7
   \                     ??ZDSecMgrSetupPartner_1:
   \   00003C   700F         JNZ     ??ZDSecMgrSetupPartner_2
   3252              {
   3253                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00003E                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   00003E   7D00         MOV     R5,#0x0
   \   000040   7C00         MOV     R4,#0x0
   \   000042   7900         MOV     R1,#0x0
   \   000044   AA..         MOV     R2,?V0 + 0
   \   000046   AB..         MOV     R3,?V0 + 1
   \   000048   12....       LCALL   ??ZDP_NwkAddrReq?relay
   \   00004B   8017         SJMP    ??ZDSecMgrSetupPartner_3
   3254              }
   3255              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   00004D                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00004D   AA..         MOV     R2,?V0 + 0
   \   00004F   AB..         MOV     R3,?V0 + 1
   \   000051   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000054   E9           MOV     A,R1
   \   000055   7010         JNZ     ??ZDSecMgrSetupPartner_0
   3256              {
   3257                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000057                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000057   7D00         MOV     R5,#0x0
   \   000059   7C00         MOV     R4,#0x0
   \   00005B   7900         MOV     R1,#0x0
   \   00005D   EE           MOV     A,R6
   \   00005E   FA           MOV     R2,A
   \   00005F   EF           MOV     A,R7
   \   000060   FB           MOV     R3,A
   \   000061   12....       LCALL   ??ZDP_IEEEAddrReq?relay
   \                     ??ZDSecMgrSetupPartner_3:
   \   000064   E9           MOV     A,R1
   \   000065   F5..         MOV     ?V0 + 2,A
   3258              }
   3259            }
   3260          
   3261            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000067   A9..         MOV     R1,?V0 + 2
   \   000069   740D         MOV     A,#0xd
   \   00006B                REQUIRE ?Subroutine4
   \   00006B                ; // Fall through to label ?Subroutine4
   3262          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F03         MOV     R7,#0x3
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
   3263          #endif // ( ZG_BUILD_JOINING_TYPE )
   3264          
   3265          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3266          /******************************************************************************
   3267           * @fn          ZDSecMgrAppKeyTypeSet
   3268           *
   3269           * @brief       Set application key type.
   3270           *
   3271           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3272           *                                                   KEY_TYPE_APP_LINK@3
   3273           *
   3274           * @return      ZStatus_t
   3275           */
   3276          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3277          {
   3278            if ( keyType == KEY_TYPE_APP_LINK )
   3279            {
   3280              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3281            }
   3282            else
   3283            {
   3284              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3285            }
   3286          
   3287            return ZSuccess;
   3288          }
   3289          #endif
   3290          
   3291          /******************************************************************************
   3292           * ZigBee Device Security Manager - Stub Implementations
   3293           */
   3294          /******************************************************************************
   3295           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3296           *
   3297           * @brief       Get MASTER key for specified EXT address.
   3298           *
   3299           * @param       extAddr - [in] EXT address
   3300           * @param       key     - [out] MASTER key
   3301           *
   3302           * @return      ZStatus_t
   3303           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3304          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint8** key )
   \                     APSME_MasterKeyGet:
   3305          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3306            ZStatus_t status;
   3307            uint16    ami;
   3308          
   3309          
   3310            // lookup entry for specified EXT address
   3311            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   3312            //status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3313          
   3314            if ( status == ZSuccess )
   \   00001E   700F         JNZ     ??APSME_MasterKeyGet_0
   3315            {
   3316              ZDSecMgrMasterKeyLookup( ami, key );
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   EE           MOV     A,R6
   \   000021   FC           MOV     R4,A
   \   000022   EF           MOV     A,R7
   \   000023   FD           MOV     R5,A
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   12....       LCALL   ?Subroutine48 & 0xFFFF
   3317            }
   \                     ??CrossCallReturnLabel_58:
   \   00002D   8008         SJMP    ??APSME_MasterKeyGet_1
   3318            else
   3319            {
   3320              *key = NULL;
   \                     ??APSME_MasterKeyGet_0:
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E4           CLR     A
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   F0           MOVX    @DPTR,A
   3321            }
   3322          
   3323            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   000037   02....       LJMP    ?Subroutine1 & 0xFFFF
   3324          }
   3325          
   3326          /******************************************************************************
   3327           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3328           *
   3329           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3330           *
   3331           * @param       extAddr - [in] EXT address
   3332           * @param       data    - [in] APSME_LinkKeyData_t
   3333           *
   3334           * @return      ZStatus_t
   3335           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3336          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3337          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 0,R4
   \   00000C   8D..         MOV     ?V0 + 1,R5
   3338            ZStatus_t        status;
   3339            ZDSecMgrEntry_t* entry;
   3340          
   3341          
   3342            // lookup entry index for specified EXT address
   3343            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   FE           MOV     R6,A
   3344          
   3345            if ( status == ZSuccess )
   \   00001D   7046         JNZ     ??APSME_LinkKeySet_0
   3346            {
   3347              // setup the link key data reference
   3348              osal_memcpy( entry->lkd.key, key, SEC_KEY_LEN );
   \   00001F                ; Setup parameters for call to function osal_memcpy
   \   00001F   75..00       MOV     ?V0 + 2,#0x0
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000027   7C10         MOV     R4,#0x10
   \   000029   7D00         MOV     R5,#0x0
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000033   12....       LCALL   ??osal_memcpy?relay
   \   000036   7403         MOV     A,#0x3
   \   000038   12....       LCALL   ?DEALLOC_XSTACK8
   3349          
   3350              entry->lkd.apsmelkd.rxFrmCntr = 0;
   \   00003B   90....       MOV     DPTR,#__Constant_0
   \   00003E   12....       LCALL   ?XLOAD_R2345
   \   000041   85..82       MOV     DPL,?XSP + 0
   \   000044   85..83       MOV     DPH,?XSP + 1
   \   000047   E0           MOVX    A,@DPTR
   \   000048   2418         ADD     A,#0x18
   \   00004A   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00004D   12....       LCALL   ?XSTORE_R2345
   3351              entry->lkd.apsmelkd.txFrmCntr = 0;
   \   000050   90....       MOV     DPTR,#__Constant_0
   \   000053   12....       LCALL   ?XLOAD_R2345
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   2414         ADD     A,#0x14
   \   00005F   12....       LCALL   ?Subroutine38 & 0xFFFF
   3352            }
   \                     ??CrossCallReturnLabel_38:
   \   000062   12....       LCALL   ?XSTORE_R2345
   3353          
   3354            return status;
   \                     ??APSME_LinkKeySet_0:
   \   000065   EE           MOV     A,R6
   \   000066   F9           MOV     R1,A
   \   000067   7402         MOV     A,#0x2
   \   000069   02....       LJMP    ?Subroutine4 & 0xFFFF
   3355          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2402         ADD     A,#0x2
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3356          
   3357          /******************************************************************************
   3358           * @fn          ZDSecMgrAuthenticationSet
   3359           *
   3360           * @brief       Mark the specific device as authenticated or not
   3361           *
   3362           * @param       extAddr - [in] EXT address
   3363           * @param       option  - [in] authenticated or not
   3364           *
   3365           * @return      ZStatus_t
   3366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3367          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3368          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   3369            ZStatus_t        status;
   3370            ZDSecMgrEntry_t* entry;
   3371          
   3372          
   3373            // lookup entry index for specified EXT address
   3374            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   AC82         MOV     R4,DPL
   \   000014   AD83         MOV     R5,DPH
   \   000016   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000019   E9           MOV     A,R1
   3375          
   3376            if ( status == ZSuccess )
   \   00001A   7015         JNZ     ??ZDSecMgrAuthenticationSet_0
   3377            {
   3378              entry->authenticateOption = option;
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   241C         ADD     A,#0x1c
   \   000025   FA           MOV     R2,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   3400         ADDC    A,#0x0
   \   00002A   FB           MOV     R3,A
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   EE           MOV     A,R6
   \   000030   F0           MOVX    @DPTR,A
   3379            }
   3380          
   3381            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000031   02....       LJMP    ??Subroutine87_0 & 0xFFFF
   3382          }
   3383          
   3384          /******************************************************************************
   3385           * @fn          ZDSecMgrAuthenticationCheck
   3386           *
   3387           * @brief       Check if the specific device has been authenticated or not
   3388           *              For non-trust center device, always return true
   3389           *
   3390           * @param       shortAddr - [in] short address
   3391           *
   3392           * @return      TRUE @ authenticated with CBKE
   3393           *              FALSE @ not authenticated
   3394           */
   3395          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3396          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3397          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3398          #if defined (SE_PROFILE)
   3399          
   3400            ZDSecMgrEntry_t* entry;
   3401            uint8 extAddr[Z_EXTADDR_LEN];
   3402          
   3403            // If the local device is not the trust center, always return TRUE
   3404            if ( NLME_GetShortAddr() != TCshortAddr )
   3405            {
   3406              return TRUE;
   3407            }
   3408            // Otherwise, check the authentication option
   3409            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3410            {
   3411              // lookup entry index for specified EXT address
   3412              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3413              {
   3414                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3415                {
   3416                  return TRUE;
   3417                }
   3418                else
   3419                {
   3420                  return FALSE;
   3421                }
   3422              }
   3423            }
   3424            return FALSE;
   3425          
   3426          #else
   3427            (void)shortAddr;  // Intentionally unreferenced parameter
   3428            
   3429            // For non AMI/SE Profile, perform no check and always return true.
   3430            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3431          
   3432          #endif // SE_PROFILE
   3433          }
   3434          
   3435          
   3436          /******************************************************************************
   3437           * @fn          ZDSecMgrLinkKeyDataGet (stubs APSME_LinkKeyDataGet)
   3438           *
   3439           * @brief       Get <APSME_LinkKeyData_t> for specified NWK address.
   3440           *
   3441           * @param       extAddr - [in] EXT address
   3442           * @param       data    - [out] APSME_LinkKeyData_t
   3443           *
   3444           * @return      ZStatus_t
   3445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3446          ZStatus_t ZDSecMgrLinkKeyDataGet(uint8* extAddr, APSME_LinkKeyData_t** data)
   \                     APSME_LinkKeyDataGet:
   3447          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3448            ZStatus_t        status;
   3449            ZDSecMgrEntry_t* entry;
   3450          
   3451          
   3452            // lookup entry index for specified NWK address
   3453            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   3454          
   3455            if ( status == ZSuccess )
   \   00001C   702C         JNZ     ??APSME_LinkKeyDataGet_0
   3456            {
   3457              // setup the link key data reference
   3458              (*data) = &entry->lkd.apsmelkd;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   2412         ADD     A,#0x12
   \   000027   FA           MOV     R2,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   3400         ADDC    A,#0x0
   \   00002C   FB           MOV     R3,A
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   12....       LCALL   ??Subroutine96_0 & 0xFFFF
   3459              (*data)->key = entry->lkd.key;
   \                     ??CrossCallReturnLabel_204:
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   12....       LCALL   ?Subroutine51 & 0xFFFF
   3460            }
   \                     ??CrossCallReturnLabel_62:
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000044   EA           MOV     A,R2
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   EB           MOV     A,R3
   \   000048   8007         SJMP    ??APSME_LinkKeyDataGet_1
   3461            else
   3462            {
   3463              *data = NULL;
   \                     ??APSME_LinkKeyDataGet_0:
   \   00004A   8E82         MOV     DPL,R6
   \   00004C   8F83         MOV     DPH,R7
   \   00004E   E4           CLR     A
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   A3           INC     DPTR
   \                     ??APSME_LinkKeyDataGet_1:
   \   000051   F0           MOVX    @DPTR,A
   3464            }
   3465          
   3466            return status;
   \   000052   02....       LJMP    ??Subroutine87_0 & 0xFFFF
   3467          }
   3468          
   3469          /******************************************************************************
   3470           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3471           *
   3472           * @brief       Verify and process key transportation to child.
   3473           *
   3474           * @param       ind - [in] APSME_TransportKeyInd_t
   3475           *
   3476           * @return      uint8 - success(TRUE:FALSE)
   3477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3478          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3479          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3480            uint8 success;
   3481          
   3482            success = FALSE;
   \   000005   7E00         MOV     R6,#0x0
   3483          
   3484            // verify from Trust Center
   3485            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   00000E   7027         JNZ     ??APSME_KeyFwdToChild_0
   3486            {
   3487              success = TRUE;
   \   000010   0E           INC     R6
   3488          
   3489              // check for initial NWK key
   3490              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3491                   ( ind->keyType == 6                 ) ||
   3492                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   EE           MOV     A,R6
   \   00001A   68           XRL     A,R0
   \   00001B   600A         JZ      ??APSME_KeyFwdToChild_1
   \   00001D   7406         MOV     A,#0x6
   \   00001F   68           XRL     A,R0
   \   000020   6005         JZ      ??APSME_KeyFwdToChild_1
   \   000022   7405         MOV     A,#0x5
   \   000024   68           XRL     A,R0
   \   000025   7010         JNZ     ??APSME_KeyFwdToChild_0
   3493              {
   3494                // set association status to authenticated
   3495                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   000027                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000027                ; Setup parameters for call to function AssocGetWithExt
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   12....       LCALL   ?Subroutine49 & 0xFFFF
   3496              }
   3497            }
   \                     ??CrossCallReturnLabel_60:
   \   000034   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   3498          
   3499            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   000037   EE           MOV     A,R6
   \   000038   F9           MOV     R1,A
   \   000039   02....       LJMP    ??Subroutine89_0 & 0xFFFF
   3500          }
   3501          
   3502          /******************************************************************************
   3503           * @fn          ZDSecMgrAddLinkKey
   3504           *
   3505           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3506           *              as authenticated in the authenticateOption. Note that this function
   3507           *              is hardwared to CBKE right now.
   3508           *
   3509           * @param       shortAddr - short address of the partner device
   3510           * @param       extAddr - extended address of the partner device
   3511           * @param       key - link key
   3512           *
   3513           * @return      none
   3514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3515          void ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3516          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   7410         MOV     A,#0x10
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   3517            uint16           ami;
   3518            ZDSecMgrEntry_t* entry;
   3519          
   3520            ZDSecMgrAddrStore( shortAddr, extAddr, &ami );
   \   00001A                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   8582..       MOV     ?V0 + 2,DPL
   \   000022   8583..       MOV     ?V0 + 3,DPH
   \   000025   78..         MOV     R0,#?V0 + 2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   3521          
   3522            ZDSecMgrEntryLookupAMI( ami, &entry );
   \   000032                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine45 & 0xFFFF
   3523          
   3524            // If no existing entry, create one
   3525            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_52:
   \   000044   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000047   7023         JNZ     ??CrossCallReturnLabel_190
   3526            {
   3527              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000049                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   AA82         MOV     R2,DPL
   \   000051   AB83         MOV     R3,DPH
   \   000053   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000056   E9           MOV     A,R1
   \   000057   7013         JNZ     ??CrossCallReturnLabel_190
   3528              {
   3529                entry->ami = ami;
   \   000059   7402         MOV     A,#0x2
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   12....       LCALL   ?Subroutine43 & 0xFFFF
   3530              }
   3531            }
   \                     ??CrossCallReturnLabel_50:
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FA           MOV     R2,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F583         MOV     DPH,A
   \   000067   8A82         MOV     DPL,R2
   \   000069   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   3532            // Write the link key
   3533            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_190:
   \   00006C                ; Setup parameters for call to function APSME_LinkKeySet
   \   00006C   AC..         MOV     R4,?V0 + 0
   \   00006E   AD..         MOV     R5,?V0 + 1
   \   000070   EE           MOV     A,R6
   \   000071   FA           MOV     R2,A
   \   000072   EF           MOV     A,R7
   \   000073   FB           MOV     R3,A
   \   000074   12....       LCALL   ??APSME_LinkKeySet?relay
   3534          
   3535          #if defined (SE_PROFILE)
   3536            // Mark the device as authenticated.
   3537            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3538          #endif
   3539          
   3540            // Write the new established link key to NV.
   3541            ZDSecMgrWriteNV();
   \   000077                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   000077   12....       LCALL   ??ZDSecMgrWriteNV?relay
   3542          }
   \   00007A   7404         MOV     A,#0x4
   \   00007C   02....       LJMP    ??Subroutine104_0 & 0xFFFF
   3543          
   3544          /******************************************************************************
   3545           * @fn          ZDSecMgrInitNV
   3546           *
   3547           * @brief       Initialize the SecMgr entry data in NV.
   3548           *
   3549           * @param       none
   3550           *
   3551           * @return      uint8 - <osal_nv_item_init> return codes
   3552           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3553          uint8 ZDSecMgrInitNV( void )
   \                     ZDSecMgrInitNV:
   3554          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3555            uint8  status;
   3556            uint16 size;
   3557          
   3558            size = (uint16)( sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX );
   3559          
   3560            status = osal_nv_item_init( ZCD_NV_APS_LINK_KEY_TABLE, size, NULL );
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005   E4           CLR     A
   \   000006   F5..         MOV     ?V0 + 0,A
   \   000008   F5..         MOV     ?V0 + 1,A
   \   00000A   78..         MOV     R0,#?V0 + 0
   \   00000C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000F   7C57         MOV     R4,#0x57
   \   000011   7D00         MOV     R5,#0x0
   \   000013   7A4C         MOV     R2,#0x4c
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??osal_nv_item_init?relay
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001F   E9           MOV     A,R1
   \   000020   FE           MOV     R6,A
   3561          
   3562            // The item does not already exist
   3563            if ( status != ZSUCCESS )
   \   000021   6003         JZ      ??ZDSecMgrInitNV_0
   3564            {
   3565              ZDSecMgrSetDefaultNV();
   \   000023                ; Setup parameters for call to function ZDSecMgrSetDefaultNV
   \   000023   12....       LCALL   ??ZDSecMgrSetDefaultNV?relay
   3566            }
   3567          
   3568            return status;
   \                     ??ZDSecMgrInitNV_0:
   \   000026   EE           MOV     A,R6
   \   000027   F9           MOV     R1,A
   \   000028   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   3569          }
   3570          
   3571          
   3572          /******************************************************************************
   3573           * @fn          ZDSecMgrSetDefaultNV
   3574           *
   3575           * @brief       Set default SecMgr entry data in NV.
   3576           *
   3577           * @param       none
   3578           *
   3579           * @return      none
   3580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   8582..       MOV     ?V0 + 0,DPL
   \   000009   8583..       MOV     ?V0 + 1,DPH
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000011   75..02       MOV     ?V0 + 0,#0x2
   \   000014   75..00       MOV     ?V0 + 1,#0x0
   \   000017   78..         MOV     R0,#?V0 + 0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   7C00         MOV     R4,#0x0
   \   00001E   7D00         MOV     R5,#0x0
   \   000020   7A4C         MOV     R2,#0x4c
   \   000022   7B00         MOV     R3,#0x0
   \   000024   12....       LCALL   ??osal_nv_write?relay
   \   000027   7404         MOV     A,#0x4
   \   000029   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002C                REQUIRE ??Subroutine98_0
   \   00002C                ; // Fall through to label ??Subroutine98_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3581          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3582          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3583            nvDeviceListHdr_t hdr;
   3584          
   3585            // Initialize the header
   3586            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   3587          
   3588            // Save off the header
   3589            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   02....       LJMP    ?Subroutine2 & 0xFFFF
   3590          }
   3591          
   3592          
   3593          
   3594          /*********************************************************************
   3595           * @fn      ZDSecMgrWriteNV()
   3596           *
   3597           * @brief   Save off the link key list to NV
   3598           *
   3599           * @param   none
   3600           *
   3601           * @return  none
   3602           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3603          void ZDSecMgrWriteNV( void )
   \                     ZDSecMgrWriteNV:
   3604          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3605            uint16 i;
   3606            nvDeviceListHdr_t hdr;
   3607          
   3608            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   3609          
   3610            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000014   FE           MOV     R6,A
   \   000015   FF           MOV     R7,A
   3611            {
   3612              if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   \                     ??ZDSecMgrWriteNV_0:
   \   000016   EE           MOV     A,R6
   \   000017   F8           MOV     R0,A
   \   000018   EF           MOV     A,R7
   \   000019   F9           MOV     R1,A
   \   00001A   E8           MOV     A,R0
   \   00001B   75F01D       MOV     B,#0x1d
   \   00001E   A4           MUL     AB
   \   00001F   F8           MOV     R0,A
   \   000020   AAF0         MOV     R2,B
   \   000022   75F01D       MOV     B,#0x1d
   \   000025   E9           MOV     A,R1
   \   000026   A4           MUL     AB
   \   000027   2A           ADD     A,R2
   \   000028   F9           MOV     R1,A
   \   000029   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   28           ADD     A,R0
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   39           ADDC    A,R1
   \   000033   F5..         MOV     ?V0 + 1,A
   \   000035   85..82       MOV     DPL,?V0 + 0
   \   000038   F583         MOV     DPH,A
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   64FE         XRL     A,#0xfe
   \   00003D   7003         JNZ     ??ZDSecMgrWriteNV_1
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F4           CPL     A
   \                     ??ZDSecMgrWriteNV_1:
   \   000042   604A         JZ      ??ZDSecMgrWriteNV_2
   3613              {
   3614                // Save off the record
   3615                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3616                        (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3617                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   \   000044                ; Setup parameters for call to function osal_nv_write
   \   000044   78..         MOV     R0,#?V0 + 0
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   75..1D       MOV     ?V0 + 0,#0x1d
   \   00004C   75..00       MOV     ?V0 + 1,#0x0
   \   00004F   78..         MOV     R0,#?V0 + 0
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   7404         MOV     A,#0x4
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   00005C   E8           MOV     A,R0
   \   00005D   75F01D       MOV     B,#0x1d
   \   000060   A4           MUL     AB
   \   000061   F8           MOV     R0,A
   \   000062   AAF0         MOV     R2,B
   \   000064   75F01D       MOV     B,#0x1d
   \   000067   E9           MOV     A,R1
   \   000068   A4           MUL     AB
   \   000069   2A           ADD     A,R2
   \   00006A   F9           MOV     R1,A
   \   00006B   E8           MOV     A,R0
   \   00006C   2402         ADD     A,#0x2
   \   00006E   FC           MOV     R4,A
   \   00006F   E9           MOV     A,R1
   \   000070   3400         ADDC    A,#0x0
   \   000072   FD           MOV     R5,A
   \   000073   7A4C         MOV     R2,#0x4c
   \   000075   7B00         MOV     R3,#0x0
   \   000077   12....       LCALL   ??osal_nv_write?relay
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   3618                hdr.numRecs++;
   \   00007F   85..82       MOV     DPL,?XSP + 0
   \   000082   85..83       MOV     DPH,?XSP + 1
   \   000085   E0           MOVX    A,@DPTR
   \   000086   2401         ADD     A,#0x1
   \   000088   F0           MOVX    @DPTR,A
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   3400         ADDC    A,#0x0
   \   00008D   F0           MOVX    @DPTR,A
   3619              }
   3620            }
   \                     ??ZDSecMgrWriteNV_2:
   \   00008E   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000091   4083         JC      ??ZDSecMgrWriteNV_0
   3621          
   3622            // Save off the header
   3623            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \   000093                ; Setup parameters for call to function osal_nv_write
   \   000093   02....       LJMP    ?Subroutine2 & 0xFFFF
   3624          }
   3625          
   3626          /******************************************************************************
   3627           * @fn          ZDSecMgrRestoreFromNV
   3628           *
   3629           * @brief       Restore the SecMgr entry data from NV.
   3630           *
   3631           * @param       none
   3632           *
   3633           * @return      ZStatus_t ZSuccess or ZFailure
   3634           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3635          ZStatus_t ZDSecMgrRestoreFromNV( void )
   \                     ZDSecMgrRestoreFromNV:
   3636          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3637            uint8 x = 0;
   \   00000A   75..00       MOV     ?V0 + 4,#0x0
   3638            nvDeviceListHdr_t hdr;
   3639          
   3640            // Initialize the device list
   3641            if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr ) == ZSUCCESS )
   \   00000D                ; Setup parameters for call to function osal_nv_read
   \   00000D   85..82       MOV     DPL,?XSP + 0
   \   000010   85..83       MOV     DPH,?XSP + 1
   \   000013   8582..       MOV     ?V0 + 0,DPL
   \   000016   8583..       MOV     ?V0 + 1,DPH
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001E   75..02       MOV     ?V0 + 0,#0x2
   \   000021   75..00       MOV     ?V0 + 1,#0x0
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   7C00         MOV     R4,#0x0
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   7A4C         MOV     R2,#0x4c
   \   00002F   7B00         MOV     R3,#0x0
   \   000031   12....       LCALL   ??osal_nv_read?relay
   \   000034   7404         MOV     A,#0x4
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
   \   000039   E9           MOV     A,R1
   \   00003A   606F         JZ      ??ZDSecMgrRestoreFromNV_0
   3642            {
   3643              // Read in the device list
   3644              for ( ; x < hdr.numRecs; x++ )
   3645              {
   3646                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3647                          (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3648                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == ZSUCCESS )
   3649                {
   3650                  ZDSecMgrEntries[x].lkd.apsmelkd.txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3651                }
   3652              }
   3653          
   3654              // Write the updated entry back to NV.
   3655              ZDSecMgrWriteNV();
   3656          
   3657              return ZSuccess;
   3658            }
   3659            return ZFailure;
   \   00003C   7901         MOV     R1,#0x1
   \                     ??ZDSecMgrRestoreFromNV_1:
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
   \   000043   7F05         MOV     R7,#0x5
   \   000045   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??ZDSecMgrRestoreFromNV_2:
   \   000048   EA           MOV     A,R2
   \   000049   75F01D       MOV     B,#0x1d
   \   00004C   A4           MUL     AB
   \   00004D   FE           MOV     R6,A
   \   00004E   AFF0         MOV     R7,B
   \   000050                ; Setup parameters for call to function osal_nv_read
   \   000050   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000053   E0           MOVX    A,@DPTR
   \   000054   2E           ADD     A,R6
   \   000055   F5..         MOV     ?V0 + 0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   3F           ADDC    A,R7
   \   00005A   F5..         MOV     ?V0 + 1,A
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   75..1D       MOV     ?V0 + 0,#0x1d
   \   000064   75..00       MOV     ?V0 + 1,#0x0
   \   000067   78..         MOV     R0,#?V0 + 0
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   EA           MOV     A,R2
   \   00006D   75F01D       MOV     B,#0x1d
   \   000070   A4           MUL     AB
   \   000071   2402         ADD     A,#0x2
   \   000073   FC           MOV     R4,A
   \   000074   E5F0         MOV     A,B
   \   000076   3400         ADDC    A,#0x0
   \   000078   FD           MOV     R5,A
   \   000079   7A4C         MOV     R2,#0x4c
   \   00007B   7B00         MOV     R3,#0x0
   \   00007D   12....       LCALL   ??osal_nv_read?relay
   \   000080   7404         MOV     A,#0x4
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   E9           MOV     A,R1
   \   000086   7021         JNZ     ??ZDSecMgrRestoreFromNV_3
   \   000088   90....       MOV     DPTR,#__Constant_b
   \   00008B   78..         MOV     R0,#?V0 + 0
   \   00008D   12....       LCALL   ?L_MOV_X
   \   000090   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000093   E0           MOVX    A,@DPTR
   \   000094   2E           ADD     A,R6
   \   000095   F8           MOV     R0,A
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   3F           ADDC    A,R7
   \   000099   F9           MOV     R1,A
   \   00009A   E8           MOV     A,R0
   \   00009B   2414         ADD     A,#0x14
   \   00009D   F582         MOV     DPL,A
   \   00009F   E9           MOV     A,R1
   \   0000A0   3400         ADDC    A,#0x0
   \   0000A2   F583         MOV     DPH,A
   \   0000A4   78..         MOV     R0,#?V0 + 0
   \   0000A6   12....       LCALL   ?L_ADD_TO_X
   \                     ??ZDSecMgrRestoreFromNV_3:
   \   0000A9   05..         INC     ?V0 + 4
   \                     ??ZDSecMgrRestoreFromNV_0:
   \   0000AB   85..82       MOV     DPL,?V0 + 4
   \   0000AE   AA82         MOV     R2,DPL
   \   0000B0   85..82       MOV     DPL,?XSP + 0
   \   0000B3   85..83       MOV     DPH,?XSP + 1
   \   0000B6   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   0000B9   C3           CLR     C
   \   0000BA   EA           MOV     A,R2
   \   0000BB   98           SUBB    A,R0
   \   0000BC   E4           CLR     A
   \   0000BD   99           SUBB    A,R1
   \   0000BE   4088         JC      ??ZDSecMgrRestoreFromNV_2
   \   0000C0                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   0000C0   12....       LCALL   ??ZDSecMgrWriteNV?relay
   \   0000C3   7900         MOV     R1,#0x0
   \   0000C5   02....       LJMP    ??ZDSecMgrRestoreFromNV_1 & 0xFFFF
   3660          }
   3661          
   3662          /******************************************************************************
   3663           * @fn          ZDSecMgrAPSRemove
   3664           *
   3665           * @brief       Remove device from network.
   3666           *
   3667           * @param       nwkAddr - device's NWK address
   3668           * @param       extAddr - device's Extended address
   3669           * @param       parentAddr - parent's NWK address
   3670           *
   3671           * @return      ZStatus_t
   3672           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3673          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3674          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   \   000009   740A         MOV     A,#0xa
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ??Subroutine102_0 & 0xFFFF
   3675            ZDSecMgrDevice_t device;
   3676          
   3677            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3678                 ( extAddr == NULL )              ||
   3679                 ( parentAddr == INVALID_NODE_ADDR ) )
   \                     ??CrossCallReturnLabel_231:
   \   000011   74FE         MOV     A,#-0x2
   \   000013   6A           XRL     A,R2
   \   000014   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   000016   74FF         MOV     A,#-0x1
   \   000018   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000019   600E         JZ      ??ZDSecMgrAPSRemove_1
   \   00001B   EC           MOV     A,R4
   \   00001C   4D           ORL     A,R5
   \   00001D   600A         JZ      ??ZDSecMgrAPSRemove_1
   \   00001F   74FE         MOV     A,#-0x2
   \   000021   68           XRL     A,R0
   \   000022   7003         JNZ     ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV     A,#-0x1
   \   000026   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ     ??ZDSecMgrAPSRemove_3
   3680            {
   3681              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV     R1,#0x1
   \   00002B   801A         SJMP    ??ZDSecMgrAPSRemove_4
   3682            }
   3683          
   3684            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   12....       LCALL   ?Subroutine19 & 0xFFFF
   3685            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_206:
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EC           MOV     A,R4
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   ED           MOV     A,R5
   \   000039   F0           MOVX    @DPTR,A
   3686            device.parentAddr = parentAddr;
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine12 & 0xFFFF
   3687          
   3688            // remove device
   3689            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_4:
   \   000042   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   3690          
   3691            return ( ZSuccess );
   \   000045   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000047   02....       LJMP    ?Subroutine6 & 0xFFFF
   3692          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrTCMasterKey>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_b:
   \   000000   0B000000     DD 11

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestAppKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetupPartner?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyDataGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyDataGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInitNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetDefaultNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrWriteNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrWriteNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRestoreFromNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove
   3693          
   3694          /******************************************************************************
   3695          ******************************************************************************/
   3696          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     APSME_KeyFwdToChild                0      0      9
       -> AssocGetWithExt               0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     APSME_LinkKeyDataGet               0      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     APSME_LinkKeySet                   0      0     32
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> osal_memcpy                   0      0     32
     APSME_MasterKeyGet                 0      0     11
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrMasterKeyLookup       0      0     22
     APSME_SKA_TimerExpired             0      0      0
     ZDSecMgrAPSRemove                  2      0     12
       -> ZDSecMgrDeviceRemove          4      0     20
     ZDSecMgrAddLinkKey                 0      0     20
       -> ZDSecMgrAddrStore             0      0     36
       -> ZDSecMgrEntryLookupAMI        0      0     32
       -> ZDSecMgrEntryNew              0      0     32
       -> APSME_LinkKeySet              0      0     32
       -> ZDSecMgrWriteNV               0      0     32
     ZDSecMgrAddrMgrUpdate              0      0     36
       -> AddrMgrEntryGet               0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAddrStore                  0      0     40
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAppKeyGet                  1      0     17
       -> SSP_GetTrueRand               0      0     18
     ZDSecMgrAppKeyReq                  1      0     49
       -> APSME_LookupNwkAddr           0      0     98
       -> APSME_LookupExtAddr           0      0     98
       -> SSP_GetTrueRand               0      0     98
       -> APSME_TransportKeyReq         0      0     98
       -> APSME_TransportKeyReq         0      0     98
     ZDSecMgrAssocDeviceAuth            2      0     35
     ZDSecMgrAuthInitiate               0      0     16
       -> APSME_LookupNwkAddr           0      0     32
       -> APSME_AuthenticateReq         0      0     32
     ZDSecMgrAuthNwkKey                 2      0     10
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateCfm            2      0      0
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateInd            0      0     32
       -> AddrMgrExtAddrSet             0      0     64
       -> AddrMgrEntryUpdate            0      0     64
       -> APSME_AuthenticateReq         0      0     64
     ZDSecMgrAuthenticationCheck        0      0      0
     ZDSecMgrAuthenticationSet          1      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     ZDSecMgrConfig                     2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrCtrlAdd                    0      0     26
       -> ZDSecMgrCtrlSet               0      0     28
     ZDSecMgrCtrlInit                   2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrCtrlLookup                 0      0     23
     ZDSecMgrCtrlRelease                2      0      0
     ZDSecMgrCtrlReset                  0      0     14
       -> ZDSecMgrCtrlLookup            0      0     24
       -> ZDSecMgrCtrlSet               0      0     28
       -> ZDSecMgrCtrlAdd               0      0     24
     ZDSecMgrCtrlSet                    1      0     23
     ZDSecMgrCtrlTerm                   2      0      2
       -> ZDSecMgrCtrlLookup            4      0      4
     ZDSecMgrDeviceCtrlHandler          1      0     42
       -> ZDSecMgrSendMasterKey         0      0     18
       -> ZDSecMgrEstablishKey          0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
       -> osal_start_timerEx            0      0     18
     ZDSecMgrDeviceCtrlSetup            2      0      0
       -> ZDSecMgrDeviceCtrlHandler     4      0      0
     ZDSecMgrDeviceCtrlUpdate           0      0     13
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> ZDSecMgrCtrlLookup            0      0     26
     ZDSecMgrDeviceEntryAdd             0      0     28
       -> ZDSecMgrEntryLookup           0      0     28
       -> ZDSecMgrEntryLookupAMI        0      0     28
       -> ZDSecMgrAddrMgrUpdate         0      0     28
       -> ZDSecMgrEntryLookupAMI        0      0     28
       -> ZDSecMgrEntryNew              0      0     28
       -> ZDSecMgrAddrMgrUpdate         0      0     28
     ZDSecMgrDeviceEntryRemove          2      0      0
     ZDSecMgrDeviceJoin                 0      0     19
       -> ZDSecMgrDeviceValidate        0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
       -> ZDSecMgrDeviceRemove          0      0     18
     ZDSecMgrDeviceJoinDirect           0      0      9
       -> ZDSecMgrDeviceJoin            0      0     18
       -> AssocGetWithShort             0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     ZDSecMgrDeviceJoinFwd              2      0      8
       -> APSME_UpdateDeviceReq         4      0     16
     ZDSecMgrDeviceNew                  2      0     35
       -> ZDSecMgrDeviceJoinFwd         4      0      0
     ZDSecMgrDeviceRemove               0      0     38
       -> NLME_GetShortAddr             0      0     38
       -> AssocGetWithExt               0      0     38
       -> NLME_LeaveReq                 0      0     38
       -> APSME_RemoveDeviceReq         0      0     38
     ZDSecMgrDeviceValidate             2      0      9
       -> ZDSecMgrDeviceValidateRM      4      0      0
     ZDSecMgrDeviceValidateCM           0      0     16
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLoad         0      0     28
       -> ZDSecMgrDeviceEntryAdd        0      0     28
     ZDSecMgrDeviceValidateRM           2      0      0
     ZDSecMgrDeviceValidateSKKE         0      0     42
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrMasterKeyLookup       0      0     26
       -> ZDSecMgrDeviceEntryAdd        0      0     26
     ZDSecMgrEntryFree                  2      0      0
     ZDSecMgrEntryInit                  2      0      0
       -> osal_mem_alloc                4      0      0
       -> ZDSecMgrRestoreFromNV         4      0      0
     ZDSecMgrEntryLookup                0      0     37
       -> AddrMgrEntryLookupNwk         0      0     46
     ZDSecMgrEntryLookupAMI             0      0     26
     ZDSecMgrEntryLookupExt             0      0     24
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrEntryLookupAMI        0      0     22
     ZDSecMgrEntryNew                   0      0     26
     ZDSecMgrEstablishKey               0      0     26
       -> NLME_GetShortAddr             0      0     34
       -> APSME_EstablishKeyReq         0      0     34
     ZDSecMgrEstablishKeyCfm            0      0      0
     ZDSecMgrEstablishKeyInd            1      0     29
       -> ZDSecMgrTCDataLoad            0      0     58
       -> ZDSecMgrTCExtAddrCheck        0      0     58
       -> ZDSecMgrDeviceValidateSKKE
                                        0      0     58
       -> APSME_EstablishKeyRsp         0      0     58
     ZDSecMgrEvent                      1      0     33
       -> AddrMgrEntryGet               0      0     66
       -> ZDSecMgrDeviceCtrlHandler     0      0     66
       -> osal_start_timerEx            0      0     66
     ZDSecMgrExtAddrLookup              0      0     41
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryLookupExt         0      0     44
     ZDSecMgrExtAddrStore               0      0     24
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrInit                       2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrInitNV                     0      0     12
       -> osal_nv_item_init             0      0     24
       -> ZDSecMgrSetDefaultNV          0      0     20
     ZDSecMgrMasterKeyInit              2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrMasterKeyLoad              0      0     36
       -> ZDSecMgrExtAddrLookup         0      0     38
       -> ZDSecMgrMasterKeyLookup       0      0     38
       -> osal_memcpy                   0      0     44
       -> ZDSecMgrMasterKeyStore        0      0     38
     ZDSecMgrMasterKeyLookup            0      0     33
     ZDSecMgrMasterKeyStore             0      0     36
       -> osal_memcpy                   0      0     34
       -> osal_memset                   0      0     28
     ZDSecMgrNewDeviceEvent             1      0     35
       -> AssocMatchDeviceStatus        0      0     70
       -> ZDSecMgrAssocDeviceAuth       0      0     70
       -> AddrMgrEntryGet               0      0     70
       -> NLME_GetShortAddr             0      0     70
       -> ZDSecMgrDeviceNew             0      0     70
       -> AssocRemove                   0      0     70
     ZDSecMgrPermitJoining              2      0      0
     ZDSecMgrPermitJoiningTimeout       2      0      0
     ZDSecMgrRemoveDeviceInd            0      0     19
       -> APSME_LookupNwkAddr           0      0     38
       -> NLME_GetShortAddr             0      0     38
       -> ZDSecMgrDeviceRemove          0      0     38
     ZDSecMgrRequestAppKey              2      0     12
       -> AddrMgrExtAddrLookup          4      0     24
       -> APSME_RequestKeyReq           4      0     24
     ZDSecMgrRequestKeyInd              2      0      0
       -> ZDSecMgrAppKeyReq             4      0      0
     ZDSecMgrRestoreFromNV              0      0     19
       -> osal_nv_read                  0      0     38
       -> osal_nv_read                  0      0     38
       -> ZDSecMgrWriteNV               0      0     30
     ZDSecMgrSendMasterKey              0      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     46
       -> NLME_GetShortAddr             0      0     46
       -> APSME_TransportKeyReq         0      0     46
     ZDSecMgrSendNwkKey                 1      0     34
       -> NLME_GetShortAddr             0      0     50
       -> NLME_GetShortAddr             0      0     50
       -> APSME_TransportKeyReq         0      0     50
     ZDSecMgrSetDefaultNV               0      0     26
       -> osal_nv_write                 0      0     32
     ZDSecMgrSetupPartner               0      0     24
       -> AddrMgrExtAddrSet             0      0     48
       -> AddrMgrEntryUpdate            0      0     48
       -> ZDP_NwkAddrReq                0      0     48
       -> AddrMgrExtAddrValid           0      0     48
       -> ZDP_IEEEAddrReq               0      0     48
     ZDSecMgrSwitchKeyInd               2      0      0
       -> SSP_SwitchNwkKey              4      0      0
       -> ZDApp_NVUpdate                4      0      0
     ZDSecMgrTCDataLoad                 0      0     45
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     28
       -> ZDSecMgrMasterKeyStore        0      0     28
     ZDSecMgrTCExtAddrCheck             0      0     46
       -> AddrMgrExtAddrLookup          0      0     34
       -> AddrMgrExtAddrEqual           0      0     34
     ZDSecMgrTransportKeyInd            0      0     10
       -> ZDSecMgrTCDataLoad            0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> ZDSecMgrAuthNwkKey            0      0     20
     ZDSecMgrUpdateDeviceInd            2      0     10
       -> ZDSecMgrDeviceJoin            4      0     20
     ZDSecMgrWriteNV                    0      0     32
       -> osal_nv_write                 0      0     32
       -> osal_nv_write                 0      0     32


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     ZDSecMgrTCExtAddr                         8
     ZDSecMgrTCMasterKey                      16
     ZDSecMgrTCAuthenticated                   1
     ZDSecMgrTCDataLoaded                      1
     ZDSecMgrMasterKeyData                     2
     ZDSecMgrEntries                           2
     ZDSecMgrCtrlData                          2
     ZDSecMgrPermitJoiningEnabled              1
     ZDSecMgrPermitJoiningTimed                1
     TrustCenterLinkKey                       10
     ZDSecMgrMasterKeyInit                    59
     ?Subroutine15                             8
     ??Subroutine75_0                          5
     ?Subroutine71                            16
     ?Subroutine64                            11
     ??Subroutine84_0                          6
     ??Subroutine92_0                          7
     ??Subroutine96_0                          6
     ??Subroutine103_0                         6
     ZDSecMgrAddrStore                        55
     ?Subroutine54                            10
     ?Subroutine34                            16
     ?Subroutine26                             6
     ?Subroutine25                             6
     ?Subroutine60                            13
     ?Subroutine7                              5
     ?Subroutine72                            18
     ??Subroutine88_0                          3
     ??Subroutine89_0                          5
     ?Subroutine74                             6
     ZDSecMgrExtAddrStore                     54
     ZDSecMgrExtAddrLookup                    61
     ZDSecMgrMasterKeyLookup                  79
     ?Subroutine9                              5
     ?Subroutine69                             8
     ??Subroutine76_0                          8
     ?Subroutine16                             5
     ??Subroutine77_0                         11
     ?Subroutine52                             4
     ??Subroutine100_0                         5
     ZDSecMgrMasterKeyStore                  138
     ?Subroutine39                             5
     ?Subroutine63                            12
     ZDSecMgrEntryInit                        62
     ZDSecMgrEntryLookup                     111
     ?Subroutine10                             5
     ?Subroutine14                             5
     ??Subroutine78_0                         12
     ?Subroutine73                             8
     ?Subroutine13                             4
     ??Subroutine93_0                          4
     ??Subroutine99_0                          3
     ?Subroutine68                             8
     ZDSecMgrEntryLookupAMI                   76
     ZDSecMgrEntryLookupExt                   48
     ?Subroutine67                             6
     ?Subroutine1                              2
     ??Subroutine87_0                          2
     ?Subroutine45                             7
     ZDSecMgrEntryFree                         3
     ?Subroutine0                             13
     ??Subroutine91_0                          1
     ZDSecMgrEntryNew                        119
     ZDSecMgrCtrlInit                         68
     ZDSecMgrCtrlRelease                      17
     ZDSecMgrCtrlLookup                       98
     ?Subroutine33                            14
     ??Subroutine95_0                          4
     ZDSecMgrCtrlSet                          72
     ?Subroutine24                            11
     ?Subroutine22                            10
     ?Subroutine46                            10
     ?Subroutine70                             6
     ??Subroutine102_0                         4
     ZDSecMgrCtrlAdd                          91
     ??Subroutine105_0                         5
     ZDSecMgrCtrlTerm                         47
     ??Subroutine79_0                          6
     ??Subroutine82_0                          3
     ??Subroutine83_0                          6
     ZDSecMgrCtrlReset                        79
     ?Subroutine31                             1
     ??Subroutine98_0                          2
     ZDSecMgrMasterKeyLoad                    98
     ??Subroutine86_0                          4
     ?Subroutine35                            15
     ?Subroutine47                            13
     ?Subroutine66                             9
     ZDSecMgrAppKeyType                        1
     ZDSecMgrAppKeyGet                        43
     ZDSecMgrAppKeyReq                       236
     ?Subroutine42                             6
     ?Subroutine30                            10
     ?Subroutine50                             4
     ?Subroutine56                            14
     ??Subroutine97_0                          6
     ZDSecMgrEstablishKey                     97
     ?Subroutine27                             6
     ??Subroutine80_0                          6
     ?Subroutine44                             9
     ??Subroutine101_0                         2
     ZDSecMgrSendMasterKey                   128
     ?Subroutine20                            11
     ?Subroutine40                             8
     ?Subroutine17                             6
     ?Subroutine61                             2
     ?Subroutine48                             4
     ?Subroutine62                             9
     ZDSecMgrSendNwkKey                      200
     ??Subroutine85_0                          6
     ?Subroutine19                             6
     ?Subroutine59                            11
     ??Subroutine104_0                         3
     ?Subroutine43                            10
     ZDSecMgrDeviceEntryRemove                 3
     ZDSecMgrAddrMgrUpdate                    66
     ZDSecMgrDeviceEntryAdd                  165
     ?Subroutine36                            13
     ?Subroutine23                             8
     ?Subroutine65                            10
     ?Subroutine3                              2
     ?Subroutine41                             4
     ZDSecMgrDeviceCtrlHandler               109
     ?Subroutine32                             4
     ??Subroutine81_0                          9
     ZDSecMgrDeviceCtrlSetup                  59
     ZDSecMgrDeviceCtrlUpdate                101
     ?Subroutine8                              5
     ?Subroutine38                            11
     APSME_SKA_TimerExpired                    3
     ZDSecMgrDeviceRemove                    178
     ?Subroutine28                             6
     ?Subroutine49                             7
     ZDSecMgrDeviceValidateSKKE               55
     ?Subroutine37                            13
     ZDSecMgrDeviceValidateRM                 17
     ZDSecMgrDeviceValidateCM                 87
     ZDSecMgrDeviceValidate                   48
     ZDSecMgrDeviceJoin                       36
     ?Subroutine11                             5
     ZDSecMgrDeviceJoinDirect                 28
     ZDSecMgrDeviceJoinFwd                   153
     ?Subroutine55                             3
     ??Subroutine90_0                          6
     ?Subroutine18                            13
     ZDSecMgrDeviceNew                         9
     ZDSecMgrAssocDeviceAuth                  23
     ZDSecMgrAuthInitiate                     66
     ZDSecMgrAuthNwkKey                       26
     ZDSecMgrInit                              0
     ?Subroutine5                              9
     ZDSecMgrConfig                            2
     ZDSecMgrPermitJoining                    39
     ZDSecMgrPermitJoiningTimeout             24
     ZDSecMgrNewDeviceEvent                  187
     ?Subroutine29                             3
     ??Subroutine94_0                          6
     ZDSecMgrEvent                           263
     ?Subroutine12                             8
     ?Subroutine53                            16
     ZDSecMgrEstablishKeyCfm                   3
     ZDSecMgrTCExtAddrCheck                   64
     ZDSecMgrTCDataLoad                       88
     ZDSecMgrEstablishKeyInd                 211
     ?Subroutine21                            11
     ?Subroutine57                            14
     ?Subroutine58                            11
     ZDSecMgrTransportKeyInd                 140
     ?Subroutine6                              2
     ZDSecMgrUpdateDeviceInd                  50
     ZDSecMgrRemoveDeviceInd                  82
     ZDSecMgrRequestKeyInd                    30
     ZDSecMgrSwitchKeyInd                     23
     ZDSecMgrAuthenticateInd                 130
     ZDSecMgrAuthenticateCfm                  46
     ZDSecMgrRequestAppKey                    68
     ZDSecMgrSetupPartner                    107
     ?Subroutine4                              8
     APSME_MasterKeyGet                       58
     APSME_LinkKeySet                        108
     ?Subroutine51                            10
     ZDSecMgrAuthenticationSet                52
     ZDSecMgrAuthenticationCheck               5
     APSME_LinkKeyDataGet                     85
     APSME_KeyFwdToChild                      60
     ZDSecMgrAddLinkKey                      127
     ZDSecMgrInitNV                           43
     ?Subroutine2                             44
     ZDSecMgrSetDefaultNV                     23
     ZDSecMgrWriteNV                         150
     ZDSecMgrRestoreFromNV                   200
     ZDSecMgrAPSRemove                        74
     ?<Initializer for ZDSecMgrTCMasterKey>   16
     ?<Initializer for ZDSecMgrAppKeyType>     1
     __Constant_0                              4
     __Constant_b                              4
     ??ZDSecMgrMasterKeyInit?relay             6
     ??ZDSecMgrAddrStore?relay                 6
     ??ZDSecMgrExtAddrStore?relay              6
     ??ZDSecMgrExtAddrLookup?relay             6
     ??ZDSecMgrMasterKeyLookup?relay           6
     ??ZDSecMgrMasterKeyStore?relay            6
     ??ZDSecMgrEntryInit?relay                 6
     ??ZDSecMgrEntryLookup?relay               6
     ??ZDSecMgrEntryLookupAMI?relay            6
     ??ZDSecMgrEntryLookupExt?relay            6
     ??ZDSecMgrEntryFree?relay                 6
     ??ZDSecMgrEntryNew?relay                  6
     ??ZDSecMgrCtrlInit?relay                  6
     ??ZDSecMgrCtrlRelease?relay               6
     ??ZDSecMgrCtrlLookup?relay                6
     ??ZDSecMgrCtrlSet?relay                   6
     ??ZDSecMgrCtrlAdd?relay                   6
     ??ZDSecMgrCtrlTerm?relay                  6
     ??ZDSecMgrCtrlReset?relay                 6
     ??ZDSecMgrMasterKeyLoad?relay             6
     ??ZDSecMgrAppKeyGet?relay                 6
     ??ZDSecMgrAppKeyReq?relay                 6
     ??ZDSecMgrEstablishKey?relay              6
     ??ZDSecMgrSendMasterKey?relay             6
     ??ZDSecMgrSendNwkKey?relay                6
     ??ZDSecMgrDeviceEntryRemove?relay         6
     ??ZDSecMgrAddrMgrUpdate?relay             6
     ??ZDSecMgrDeviceEntryAdd?relay            6
     ??ZDSecMgrDeviceCtrlHandler?relay         6
     ??ZDSecMgrDeviceCtrlSetup?relay           6
     ??ZDSecMgrDeviceCtrlUpdate?relay          6
     ??APSME_SKA_TimerExpired?relay            6
     ??ZDSecMgrDeviceRemove?relay              6
     ??ZDSecMgrDeviceValidateSKKE?relay        6
     ??ZDSecMgrDeviceValidateRM?relay          6
     ??ZDSecMgrDeviceValidateCM?relay          6
     ??ZDSecMgrDeviceValidate?relay            6
     ??ZDSecMgrDeviceJoin?relay                6
     ??ZDSecMgrDeviceJoinDirect?relay          6
     ??ZDSecMgrDeviceJoinFwd?relay             6
     ??ZDSecMgrDeviceNew?relay                 6
     ??ZDSecMgrAssocDeviceAuth?relay           6
     ??ZDSecMgrAuthInitiate?relay              6
     ??ZDSecMgrAuthNwkKey?relay                6
     ??ZDSecMgrInit?relay                      6
     ??ZDSecMgrConfig?relay                    6
     ??ZDSecMgrPermitJoining?relay             6
     ??ZDSecMgrPermitJoiningTimeout?relay      6
     ??ZDSecMgrNewDeviceEvent?relay            6
     ??ZDSecMgrEvent?relay                     6
     ??ZDSecMgrEstablishKeyCfm?relay           6
     ??ZDSecMgrTCExtAddrCheck?relay            6
     ??ZDSecMgrTCDataLoad?relay                6
     ??ZDSecMgrEstablishKeyInd?relay           6
     ??ZDSecMgrTransportKeyInd?relay           6
     ??ZDSecMgrUpdateDeviceInd?relay           6
     ??ZDSecMgrRemoveDeviceInd?relay           6
     ??ZDSecMgrRequestKeyInd?relay             6
     ??ZDSecMgrSwitchKeyInd?relay              6
     ??ZDSecMgrAuthenticateInd?relay           6
     ??ZDSecMgrAuthenticateCfm?relay           6
     ??ZDSecMgrRequestAppKey?relay             6
     ??ZDSecMgrSetupPartner?relay              6
     ??APSME_MasterKeyGet?relay                6
     ??APSME_LinkKeySet?relay                  6
     ??ZDSecMgrAuthenticationSet?relay         6
     ??ZDSecMgrAuthenticationCheck?relay       6
     ??APSME_LinkKeyDataGet?relay              6
     ??APSME_KeyFwdToChild?relay               6
     ??ZDSecMgrAddLinkKey?relay                6
     ??ZDSecMgrInitNV?relay                    6
     ??ZDSecMgrSetDefaultNV?relay              6
     ??ZDSecMgrWriteNV?relay                   6
     ??ZDSecMgrRestoreFromNV?relay             6
     ??ZDSecMgrAPSRemove?relay                 6

 
 6 732 bytes in segment BANKED_CODE
   450 bytes in segment BANK_RELAYS
    17 bytes in segment XDATA_I
    17 bytes in segment XDATA_ID
     8 bytes in segment XDATA_ROM_C
    28 bytes in segment XDATA_Z
 
 7 199 bytes of CODE  memory
     0 bytes of CONST memory (+ 8 bytes shared)
    45 bytes of XDATA memory

Errors: none
Warnings: none
